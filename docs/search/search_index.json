{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Stochastic Gamma Documentation This is the documentation of Stochastic Gamma Composition Framework. The contents of this page are the following: Getting started guide Buid and installation guide Stochastic Gamma Tutorials Documentation of Stochastic Gamma Modeling Language Documentation of SysML dependability extension","title":"Stochastic Gamma Documentation"},{"location":"#stochastic-gamma-documentation","text":"This is the documentation of Stochastic Gamma Composition Framework. The contents of this page are the following: Getting started guide Buid and installation guide Stochastic Gamma Tutorials Documentation of Stochastic Gamma Modeling Language Documentation of SysML dependability extension","title":"Stochastic Gamma Documentation"},{"location":"gamma-modeling/","text":"Introduction to the Gamma Language Family The Gamma Language Family consists of Gamma Expression Language, Gamma Action Language, Gamma Statechart Language, and Gamma Composition Language. The former three languages can model the behavior of atomic components in the system, and the fourth one can describe the connections between the components. Using Gamma Expression Language, one can define variables, parameters, and arithmetic and logic expressions. Using Gamma Action Language one can define sequence statements which can be expressions, procedure calls and control statements such as, if , for and while . Gamma Statechart Language is similar to UML statecharts. Gamma statecharts can specify state-based component behavior with composite and pseudo-states. One can use the Gamma Expression Language and the Gamma Action Language to define the component behavior within states and state transitions of the Gamma statecharts. Using Gamma Composition Language, one can model the structure of the system by hierarchically composing the atomic components using composite components. In Gamma Composition Language, composite components model the hierarchic containment and interaction between other components. A composite component may include subcomponents, which are instances of other atomic or other composite components. In composite components, one can model the interaction and communication between the subcomponents with channels and event-based interfaces. Gamma supports three types of interaction semantics among the components, synchronous-reactive, synchronous-cascade, and asynchronous. Gamma Composition Language uses three types of composite components to model the semantics of the interaction, synchronous reactive, synchronous cascade, and asynchronous Gamma composite components. Gamma also supports modeling with mixed semantics. In Gamma, one can mix the synchronous and asynchronous components in composition models. The detailed documentation of Gamma is available here: LINK . Synchronous components One can use synchronous reactive and cascade composite components to model systems, where the components can change states or interact with other components only if a dedicated trigger event arrives. The triggered execution of the synchronous component is called a cycle. This trigger event may be an external signal or the execution of a software component. If a trigger event occurs, the synchronous composite component systematically sends the trigger signal to its subcomponents. In synchronous reactive composite components, the subcomponents can perceive input signals, only if they are generated in the previous execution cycle. As a result, synchronous reactive composition model components where the interaction between the components is delayed by a cycle. In contrast, a cascade synchronous component specifies a linear execution or scheduling of the subcomponents. In cascade composite components, the execution order of the subcomponents is defined and, subcomponents can perceive signals even in the same cycle if the signals are generated before the execution of the component. Asynchronous components In Gamma Composition Language, one can use asynchronous components to define instantaneous interaction between the components. In asynchronous components, the state change and the output signal generation are not related to trigger signals and execution cycles. If the input of an asynchronous component is changed, then it might change the output or the state of the component instantly. In asynchronous composite components, there is no delay in the interaction between the subcomponents. In addition, GCL supports also mixed semantics in composition models. In Gamma, one can use an asynchronous adapter to wrap a synchronous component. Then the wrapped synchronous component can be placed into an asynchronous composite component. The adapter precisely defines the interaction between the synchronous component and its asynchronous environment.","title":"Gamma modeling"},{"location":"gamma-modeling/#introduction-to-the-gamma-language-family","text":"The Gamma Language Family consists of Gamma Expression Language, Gamma Action Language, Gamma Statechart Language, and Gamma Composition Language. The former three languages can model the behavior of atomic components in the system, and the fourth one can describe the connections between the components. Using Gamma Expression Language, one can define variables, parameters, and arithmetic and logic expressions. Using Gamma Action Language one can define sequence statements which can be expressions, procedure calls and control statements such as, if , for and while . Gamma Statechart Language is similar to UML statecharts. Gamma statecharts can specify state-based component behavior with composite and pseudo-states. One can use the Gamma Expression Language and the Gamma Action Language to define the component behavior within states and state transitions of the Gamma statecharts. Using Gamma Composition Language, one can model the structure of the system by hierarchically composing the atomic components using composite components. In Gamma Composition Language, composite components model the hierarchic containment and interaction between other components. A composite component may include subcomponents, which are instances of other atomic or other composite components. In composite components, one can model the interaction and communication between the subcomponents with channels and event-based interfaces. Gamma supports three types of interaction semantics among the components, synchronous-reactive, synchronous-cascade, and asynchronous. Gamma Composition Language uses three types of composite components to model the semantics of the interaction, synchronous reactive, synchronous cascade, and asynchronous Gamma composite components. Gamma also supports modeling with mixed semantics. In Gamma, one can mix the synchronous and asynchronous components in composition models. The detailed documentation of Gamma is available here: LINK .","title":"Introduction to the Gamma Language Family"},{"location":"gamma-modeling/#synchronous-components","text":"One can use synchronous reactive and cascade composite components to model systems, where the components can change states or interact with other components only if a dedicated trigger event arrives. The triggered execution of the synchronous component is called a cycle. This trigger event may be an external signal or the execution of a software component. If a trigger event occurs, the synchronous composite component systematically sends the trigger signal to its subcomponents. In synchronous reactive composite components, the subcomponents can perceive input signals, only if they are generated in the previous execution cycle. As a result, synchronous reactive composition model components where the interaction between the components is delayed by a cycle. In contrast, a cascade synchronous component specifies a linear execution or scheduling of the subcomponents. In cascade composite components, the execution order of the subcomponents is defined and, subcomponents can perceive signals even in the same cycle if the signals are generated before the execution of the component.","title":"Synchronous components"},{"location":"gamma-modeling/#asynchronous-components","text":"In Gamma Composition Language, one can use asynchronous components to define instantaneous interaction between the components. In asynchronous components, the state change and the output signal generation are not related to trigger signals and execution cycles. If the input of an asynchronous component is changed, then it might change the output or the state of the component instantly. In asynchronous composite components, there is no delay in the interaction between the subcomponents. In addition, GCL supports also mixed semantics in composition models. In Gamma, one can use an asynchronous adapter to wrap a synchronous component. Then the wrapped synchronous component can be placed into an asynchronous composite component. The adapter precisely defines the interaction between the synchronous component and its asynchronous environment.","title":"Asynchronous components"},{"location":"gamma-stochastic-modeling/","text":"Stochastic Gamma Modeling In this section, Stochastic Gamma Composition Language (SGCL) is introduced. Gamma Composition Language (GCL) uses high-level engineering modeling languages, hierarchical decomposition, and mixed semantics to facilitate the modeling of complex CPS systems, yet GCL can model only deterministic functional behavior. SGCL is based on GCL and extends mixed semantics modeling with stochastic components for extra-functional modeling of dependable cyber-physical systems. The semantics of SGCL is available here: LINK . As a result, engineers can develop the extra-functional model of the CPS systems by extending the functional GCL behavior with extra-functional, stochastic modeling elements. A typical use-case for SGCL is extending the synchronous software model with a stochastic asynchronous environment model. Using stochastic components, engineers can directly model unpredictable phenomena within the CPS system or in its environment, such as random hardware failures, communication or process delays, measurement noise, lost communication packages, and user requests. Stochastic Composition Models Asynchronous Composition Using SGCL, one can use asynchronous composite components, to define structure models where the components can interact instantaneously. Similarly to synchronous composite components, an asynchronous composite component can contain ports, port bindings, asynchronous component instances, and channels. In asynchronous composite components if there is an incoming event in the input port of a subcomponent then the event affects the other parts of the component right away. Stochastic asynchronous composite components are asynchronous composite components, which can contain elementary stochastic components and the instances of other stochastic asynchronous components. In addition, stochastic asynchronous composite components can contain deterministic asynchronous component instances. One can define a deterministic and a stochastic asynchronous composite component using the async and the stochastic async keywords respectively. In all other aspects, the definition of asynchronous composite components is the same as the definition of the synchronous composite components. stochastic async Component1 [ //ports ]{ //components, channels and bindings } Synchronous Composition Synchronous composite components are structure definitions, which contain deterministic synchronous component instances, the channels between the subcomponents and port bindings. If a composite component recieves a trigger event, then the component sequentially executes its subcomponents. During execution, the events in the channels are transmitted among the subcomponents. The execution order and the rules of event transmission are defined by the type of the composite component, which can be a synchronous-reactive or cascade. Stochastic synchronous composite components are synchronous composite components, which can contain stochastic subcomponents. Similarly to a deterministic component, a stochastic synchronous component may have synchronous-reactive and cascade behavior. A stochastic synchronous components may contain elementary stochastic components and stochastic synchronous composite component instances beside deterministic synchronous component instances. Using stochastic components, engineers can model the extra-functional properties of the software components, such as communication messages are lost with a given probability or a software component fails seemingly at random times. One can use the sync , cascade , stochastic sync and stochastic cascade keywords to define the aforementioned types of composite components. After the keyword, the name of the component shall be specified. The channels, port bindings, and component instances shall be specified within curly brackets. stochastic sync Component1 [ //ports ]{ //components, channels and bindings } //... stochastic cascade Component2 [ //ports ]{ //components, channels and bindings } Elementary Stochastic Components In SGCL, the deterministic and the stochastic behavior models are separated completely. I can add stochastic behavior to the deterministic descriptions with elementary stochastic components. The class diagram of the stochastic behavior models is depicted below. Elementary stochastic components are atomic components, where the occurrence of the output events has stochastic behavior. There are five types of elementary stochastic components, such as stochastic event source, stochastic delay, stochastic switch, and stochastic sample. Each type models a different kind of stochastic behavior that may occur in CPS systems. Elementary stochastic components can model that an event occurs randomly, an event is delayed randomly, an event goes out in a randomly selected port, and an event has a random parameter. Stochastic Rules In elementary stochastic components, one can assign a stochastic model to output events with stochastic rules. A stochastic rule contains a stochastic model and an event filter, which references a set of output events of the elementary stochastic component. A stochastic model can be a distribution or a probability. In stochastic rules, engineers can use arbitrary distributions even multinomial and time-dependent distributions. There are three types of event filters: port event filter, port filter, and component filter. The port event filter references a given event of a given output port. The port filter references all events of a given output port. The component filter reference all output events of all output ports. In a stochastic component, an output event can be specified by two different event filters if the type of the event filters is not the same. In this case, the more specific event filter will assign a stochastic model to the output event. For example, in a stochastic component, there are two stochastic rules: one has a component filter, and one has a port event filter. Then in this component, the stochastic rule with the port event filter specifies assigning a stochastic model to an output event. All the other output events have the stochastic model of the rule with the component filter. Stochastic Event Source In SGCL models, stochastic event sources define components that generate output events in a randomly selected time. The time when a stochastic event source activates its outgoing events is determined by distribution. The distribution of the occurrence time is assigned to the output events by stochastic rules. In stochastic event sources, each outgoing event is activated only once per simulation. A stochastic event source contains any number of output ports but no input port. Stochastic event sources can model one-time random events such as random hardware failures. There is another type of stochastic event source called stochastic periodic event source. In contrast, stochastic periodic event sources can activate their output events multiple times. The periodicity of the events is defined by a stochastic distribution. As a result, the occurrence of the output events follows a renewable process. Stochastic periodic event sources can model user requests, transient faults, and clock events. source EvenSource1 port Port1 : provides Interface1 { Port1.Event1 : Exponential(10.0); } periodic source EvenSource2 port Port1 : provides Interface1 { Port1.Event1 : Exponential(10.0); } Stochastic Delay Stochastic delay components send out all incoming events after a random delay. A stochastic delay component contains only one input and output port, which has the same interface. A stochastic delay component never changes the parameters. The parameters of the input event instances are the same as the parameters of the corresponding output event instances. Stochastic delay components activate their output events after a randomly distributed time the corresponding input event occurs. The distribution of the stochastic delay is defined with stochastic rules. Stochastic delay components can model communication delays, processing delays, user interactions, and repair events. delay Delay1 port PortIn : requires Interface1 -> port PortOut : provides { PortOut.*: Normal(1.0,0.2); } Stochastic switch Stochastic switch components send out the incoming events instantaneously into a randomly selected output port. A stochastic switch component has only one input port and multiple (at least two) output ports. All the input and the output ports have to have the same interface. With stochastic rules, one can assign a probability to each outgoing port, and the sum of these probabilities has to be one. If an input event occurs, these probabilities define in which port the event will be sent out. The parameters of the input events are the same as the parameters of the corresponding output event. Stochastic switch components can model packet loss during communication and latent fault of diagnostic mechanisms. switch Switch1 port PortIn : requires Interface1 -> port PortOut1 : provides, port PortOut2 : provides, { PortOut1.* : 0.6; PortOut2.* : 0.4; } Stochastic sample Stochastic sample components have only one input and one output ports, which have the same interface. Stochastic sample components send out the input events into the output port instantaneously. The parameters of the output event instances might be different from the corresponding input event instances. I can use stochastic rules to assign a distribution to the first parameter of the output events. Therefore each time the output event is raised, the specified parameter will be a random sample of the corresponding stochastic distribution. With stochastic sample components, engineers can model sensor and diagnostic faults and measurement noise. delay Sample1 port PortIn : requires PInterface1 -> port PortOut : provides { PortOut.Event2::Parameter1 : Uniform(0.0,1.0); }","title":"Stochastic Gamma modeling"},{"location":"gamma-stochastic-modeling/#stochastic-gamma-modeling","text":"In this section, Stochastic Gamma Composition Language (SGCL) is introduced. Gamma Composition Language (GCL) uses high-level engineering modeling languages, hierarchical decomposition, and mixed semantics to facilitate the modeling of complex CPS systems, yet GCL can model only deterministic functional behavior. SGCL is based on GCL and extends mixed semantics modeling with stochastic components for extra-functional modeling of dependable cyber-physical systems. The semantics of SGCL is available here: LINK . As a result, engineers can develop the extra-functional model of the CPS systems by extending the functional GCL behavior with extra-functional, stochastic modeling elements. A typical use-case for SGCL is extending the synchronous software model with a stochastic asynchronous environment model. Using stochastic components, engineers can directly model unpredictable phenomena within the CPS system or in its environment, such as random hardware failures, communication or process delays, measurement noise, lost communication packages, and user requests.","title":"Stochastic Gamma Modeling"},{"location":"gamma-stochastic-modeling/#stochastic-composition-models","text":"","title":"Stochastic Composition Models"},{"location":"gamma-stochastic-modeling/#asynchronous-composition","text":"Using SGCL, one can use asynchronous composite components, to define structure models where the components can interact instantaneously. Similarly to synchronous composite components, an asynchronous composite component can contain ports, port bindings, asynchronous component instances, and channels. In asynchronous composite components if there is an incoming event in the input port of a subcomponent then the event affects the other parts of the component right away. Stochastic asynchronous composite components are asynchronous composite components, which can contain elementary stochastic components and the instances of other stochastic asynchronous components. In addition, stochastic asynchronous composite components can contain deterministic asynchronous component instances. One can define a deterministic and a stochastic asynchronous composite component using the async and the stochastic async keywords respectively. In all other aspects, the definition of asynchronous composite components is the same as the definition of the synchronous composite components. stochastic async Component1 [ //ports ]{ //components, channels and bindings }","title":"Asynchronous Composition"},{"location":"gamma-stochastic-modeling/#synchronous-composition","text":"Synchronous composite components are structure definitions, which contain deterministic synchronous component instances, the channels between the subcomponents and port bindings. If a composite component recieves a trigger event, then the component sequentially executes its subcomponents. During execution, the events in the channels are transmitted among the subcomponents. The execution order and the rules of event transmission are defined by the type of the composite component, which can be a synchronous-reactive or cascade. Stochastic synchronous composite components are synchronous composite components, which can contain stochastic subcomponents. Similarly to a deterministic component, a stochastic synchronous component may have synchronous-reactive and cascade behavior. A stochastic synchronous components may contain elementary stochastic components and stochastic synchronous composite component instances beside deterministic synchronous component instances. Using stochastic components, engineers can model the extra-functional properties of the software components, such as communication messages are lost with a given probability or a software component fails seemingly at random times. One can use the sync , cascade , stochastic sync and stochastic cascade keywords to define the aforementioned types of composite components. After the keyword, the name of the component shall be specified. The channels, port bindings, and component instances shall be specified within curly brackets. stochastic sync Component1 [ //ports ]{ //components, channels and bindings } //... stochastic cascade Component2 [ //ports ]{ //components, channels and bindings }","title":"Synchronous Composition"},{"location":"gamma-stochastic-modeling/#elementary-stochastic-components","text":"In SGCL, the deterministic and the stochastic behavior models are separated completely. I can add stochastic behavior to the deterministic descriptions with elementary stochastic components. The class diagram of the stochastic behavior models is depicted below. Elementary stochastic components are atomic components, where the occurrence of the output events has stochastic behavior. There are five types of elementary stochastic components, such as stochastic event source, stochastic delay, stochastic switch, and stochastic sample. Each type models a different kind of stochastic behavior that may occur in CPS systems. Elementary stochastic components can model that an event occurs randomly, an event is delayed randomly, an event goes out in a randomly selected port, and an event has a random parameter.","title":"Elementary Stochastic Components"},{"location":"gamma-stochastic-modeling/#stochastic-rules","text":"In elementary stochastic components, one can assign a stochastic model to output events with stochastic rules. A stochastic rule contains a stochastic model and an event filter, which references a set of output events of the elementary stochastic component. A stochastic model can be a distribution or a probability. In stochastic rules, engineers can use arbitrary distributions even multinomial and time-dependent distributions. There are three types of event filters: port event filter, port filter, and component filter. The port event filter references a given event of a given output port. The port filter references all events of a given output port. The component filter reference all output events of all output ports. In a stochastic component, an output event can be specified by two different event filters if the type of the event filters is not the same. In this case, the more specific event filter will assign a stochastic model to the output event. For example, in a stochastic component, there are two stochastic rules: one has a component filter, and one has a port event filter. Then in this component, the stochastic rule with the port event filter specifies assigning a stochastic model to an output event. All the other output events have the stochastic model of the rule with the component filter.","title":"Stochastic Rules"},{"location":"gamma-stochastic-modeling/#stochastic-event-source","text":"In SGCL models, stochastic event sources define components that generate output events in a randomly selected time. The time when a stochastic event source activates its outgoing events is determined by distribution. The distribution of the occurrence time is assigned to the output events by stochastic rules. In stochastic event sources, each outgoing event is activated only once per simulation. A stochastic event source contains any number of output ports but no input port. Stochastic event sources can model one-time random events such as random hardware failures. There is another type of stochastic event source called stochastic periodic event source. In contrast, stochastic periodic event sources can activate their output events multiple times. The periodicity of the events is defined by a stochastic distribution. As a result, the occurrence of the output events follows a renewable process. Stochastic periodic event sources can model user requests, transient faults, and clock events. source EvenSource1 port Port1 : provides Interface1 { Port1.Event1 : Exponential(10.0); } periodic source EvenSource2 port Port1 : provides Interface1 { Port1.Event1 : Exponential(10.0); }","title":"Stochastic Event Source"},{"location":"gamma-stochastic-modeling/#stochastic-delay","text":"Stochastic delay components send out all incoming events after a random delay. A stochastic delay component contains only one input and output port, which has the same interface. A stochastic delay component never changes the parameters. The parameters of the input event instances are the same as the parameters of the corresponding output event instances. Stochastic delay components activate their output events after a randomly distributed time the corresponding input event occurs. The distribution of the stochastic delay is defined with stochastic rules. Stochastic delay components can model communication delays, processing delays, user interactions, and repair events. delay Delay1 port PortIn : requires Interface1 -> port PortOut : provides { PortOut.*: Normal(1.0,0.2); }","title":"Stochastic Delay"},{"location":"gamma-stochastic-modeling/#stochastic-switch","text":"Stochastic switch components send out the incoming events instantaneously into a randomly selected output port. A stochastic switch component has only one input port and multiple (at least two) output ports. All the input and the output ports have to have the same interface. With stochastic rules, one can assign a probability to each outgoing port, and the sum of these probabilities has to be one. If an input event occurs, these probabilities define in which port the event will be sent out. The parameters of the input events are the same as the parameters of the corresponding output event. Stochastic switch components can model packet loss during communication and latent fault of diagnostic mechanisms. switch Switch1 port PortIn : requires Interface1 -> port PortOut1 : provides, port PortOut2 : provides, { PortOut1.* : 0.6; PortOut2.* : 0.4; }","title":"Stochastic switch"},{"location":"gamma-stochastic-modeling/#stochastic-sample","text":"Stochastic sample components have only one input and one output ports, which have the same interface. Stochastic sample components send out the input events into the output port instantaneously. The parameters of the output event instances might be different from the corresponding input event instances. I can use stochastic rules to assign a distribution to the first parameter of the output events. Therefore each time the output event is raised, the specified parameter will be a random sample of the corresponding stochastic distribution. With stochastic sample components, engineers can model sensor and diagnostic faults and measurement noise. delay Sample1 port PortIn : requires PInterface1 -> port PortOut : provides { PortOut.Event2::Parameter1 : Uniform(0.0,1.0); }","title":"Stochastic sample"},{"location":"getting-started-guide/","text":"Quick installation Dowload \u201estochastic-gamma-product.zip\u201d from LINK and unzip the content of the archive into a folder, where you want the Stochastic Gamma to be installed If you want to use SysML dependability modeling, then copy the \"ealib.jar\" from the installation library of Enterprise Architect to \" ...\\stochastic-gamma\\plugins \" folder of Stochastic Gamma installation. Download \u201ezip\u201d from LINK and extract the .zip file into a folder, where you want the python interpreter with the pre-installed python packages to be installed You can use any python interpreter if you install (matplotlib, torch, numpy and pyro-ppl). Install \u201eGraphViz\u201d Run \u201estochastic-gamma.exe\u201d Choose a \u201eworkspace\u201d location, a folder where you want to store the modeling projects. If you open a python file this pop-up window will appear, click on \u201eManual Config\u201d Click on \u201eNew\u201d and choose \u201eBrowse for python/pypy exe\u201d (you can go to this menu manually: Window/Properties/PyDev/Interpeters) Click on \u201cBrowse\u201d and find the installation location of PyroEnv and click \u201cOK\u201d and click \"OK\" again Create empty project Make sure you are using the Stochastic Gamma perspective. Click on the \"New\" button in the menu bar. In the Stochastic Gamma cathegory choose Stochastic Gamma Project and click Next . Name the project and click Next . Choose \" Stochastic Gamma Modeling Project \" and click Next . Click Finish .","title":"Getting started with Stochastic Gamma"},{"location":"getting-started-guide/#quick-installation","text":"Dowload \u201estochastic-gamma-product.zip\u201d from LINK and unzip the content of the archive into a folder, where you want the Stochastic Gamma to be installed If you want to use SysML dependability modeling, then copy the \"ealib.jar\" from the installation library of Enterprise Architect to \" ...\\stochastic-gamma\\plugins \" folder of Stochastic Gamma installation. Download \u201ezip\u201d from LINK and extract the .zip file into a folder, where you want the python interpreter with the pre-installed python packages to be installed You can use any python interpreter if you install (matplotlib, torch, numpy and pyro-ppl). Install \u201eGraphViz\u201d Run \u201estochastic-gamma.exe\u201d Choose a \u201eworkspace\u201d location, a folder where you want to store the modeling projects. If you open a python file this pop-up window will appear, click on \u201eManual Config\u201d Click on \u201eNew\u201d and choose \u201eBrowse for python/pypy exe\u201d (you can go to this menu manually: Window/Properties/PyDev/Interpeters) Click on \u201cBrowse\u201d and find the installation location of PyroEnv and click \u201cOK\u201d and click \"OK\" again","title":"Quick installation"},{"location":"getting-started-guide/#create-empty-project","text":"Make sure you are using the Stochastic Gamma perspective. Click on the \"New\" button in the menu bar. In the Stochastic Gamma cathegory choose Stochastic Gamma Project and click Next . Name the project and click Next . Choose \" Stochastic Gamma Modeling Project \" and click Next . Click Finish .","title":"Create empty project"},{"location":"sysml-allocation-modeling/","text":"SysML allocation modeling using Stochastic Gamma Abstraction Layer Profile This section introduces the modeling elements of the AbstractionLayers profile. The definitions of the stereotypes in the AbstractionLayers profile are the following: - AbstractionLayer : A collection of modeling elements, which represent the system from a given point of view - Abstrcation among layers: Abstraction relationship between two abstractio layers defines, that a given abstraction level is more abstract (or less specific), than another. The allocation is possible of those elements, of which abstraction levels are connected with this relationship. - Limitation: The current version of Stochastic Gamma supports only two abstraction levels functional and physical. Allocation rules This section defines, what kind of allocations are allowed among elements in different abstraction layers. Part allocation Rule: Within a block the allocation among parts specifies that a part requires another part for correct operation. Two blocks can be allocated to each other if they are on different abstraction levels and there is an abstraction relation between the two abstraction layers. For instance, within a EE subsystem a software component can be allocated to a microcontroller, which specifies that the microcontroller is required for the correct operation of the software component, since the microcontroller executes the software component. Two part can be allocated to each other if: The types of the parts allocated to each other OR The types of the parts specialize other blocks which are allocated to each other. Subpart allocation rule: Within a block, internal parts of other parts can be allocated to each other. For instance, a function of an EE subsystem may contain subfunctions, which can be allocated to different hardware components of the EE subsystem. Error propagation with allocation rules This section specifies the error propagation rules, yet these rules can be used for other extra-functional aspects. This set of model-transformation rules defines the semantics of the error and threat propagation. - Realized ErrorAspects without allocation: If a block realizes interfaces, then it specifies that the block can perceive the received signals of the interface. The behavior models of the block can refer to these signals in signal events. If no other rule specifies the occurrence of the signals, then the signals may occur nondeterministically. - Realized and used ErrorAspects with allocation: If a block uses a given interface than it specifies that the component can be the source of all the signal events, which are defined in the signal receptions of the used interface. If two parts are allocated to each other and the types of the parts realize and use the same interface, then the ports of the interfaces shall be connected.","title":"SysML allocation modeling"},{"location":"sysml-allocation-modeling/#sysml-allocation-modeling-using-stochastic-gamma","text":"","title":"SysML allocation modeling using Stochastic Gamma"},{"location":"sysml-allocation-modeling/#abstraction-layer-profile","text":"This section introduces the modeling elements of the AbstractionLayers profile. The definitions of the stereotypes in the AbstractionLayers profile are the following: - AbstractionLayer : A collection of modeling elements, which represent the system from a given point of view - Abstrcation among layers: Abstraction relationship between two abstractio layers defines, that a given abstraction level is more abstract (or less specific), than another. The allocation is possible of those elements, of which abstraction levels are connected with this relationship. - Limitation: The current version of Stochastic Gamma supports only two abstraction levels functional and physical.","title":"Abstraction Layer Profile"},{"location":"sysml-allocation-modeling/#allocation-rules","text":"This section defines, what kind of allocations are allowed among elements in different abstraction layers. Part allocation Rule: Within a block the allocation among parts specifies that a part requires another part for correct operation. Two blocks can be allocated to each other if they are on different abstraction levels and there is an abstraction relation between the two abstraction layers. For instance, within a EE subsystem a software component can be allocated to a microcontroller, which specifies that the microcontroller is required for the correct operation of the software component, since the microcontroller executes the software component. Two part can be allocated to each other if: The types of the parts allocated to each other OR The types of the parts specialize other blocks which are allocated to each other. Subpart allocation rule: Within a block, internal parts of other parts can be allocated to each other. For instance, a function of an EE subsystem may contain subfunctions, which can be allocated to different hardware components of the EE subsystem.","title":"Allocation rules"},{"location":"sysml-allocation-modeling/#error-propagation-with-allocation-rules","text":"This section specifies the error propagation rules, yet these rules can be used for other extra-functional aspects. This set of model-transformation rules defines the semantics of the error and threat propagation. - Realized ErrorAspects without allocation: If a block realizes interfaces, then it specifies that the block can perceive the received signals of the interface. The behavior models of the block can refer to these signals in signal events. If no other rule specifies the occurrence of the signals, then the signals may occur nondeterministically. - Realized and used ErrorAspects with allocation: If a block uses a given interface than it specifies that the component can be the source of all the signal events, which are defined in the signal receptions of the used interface. If two parts are allocated to each other and the types of the parts realize and use the same interface, then the ports of the interfaces shall be connected.","title":"Error propagation with allocation rules"},{"location":"sysml-communication-modeling/","text":"SysML communication modeling using Stochastic Gamma DataType port rule: DataType can be used as a port classifier, which is equivalent if the port's classifier is an interface block, which has exactly one flow property. The type of the flow property is the data type and the direction of the flow property is \"out\". In any other rule, a DataType is used instead of an InterfaceBlock, then this rule shall be applied. InformationFlow rule: Information flows can be used to define that port connections. If an information flow connects two ports, then it is equivalent to the connection of the two ports. If one or both end of the information flow is connected to a part instead of a port, then the conveyed item and the name of the information flow specifies the type and the name of the port, respectively. The port shall be defined in the type of the part. The connection rules are the following: If the type of the part has only one port of which type equals to the conveyed item, then the port with the same type is chosen. If the type of part has multiple ports of which type equals to the conveyed item, then the port is chosen by its name. The name of the port and the name informtion flow must be equivalent. If an information flow contains multiple conveyed items then it is equivalent to multiple information flows, with the same name and with exactly one conveyed item of the items of the original information flow. Composite port rule: If more information flows are connected to a port, than it is equivalent to composite port connection. In this case the composite port contains has multiple subports, and their name and types are specified by the name and conveyed item of the information flow. Port transmission rule: The sub-ports of the type of ports can be allocated to other blocks, which specifies that the ports has internal 'boundary' parts. Communication path rule: One can use this modeling pattern to separate the communication modeling from the information flows. As a result, one can hide all the communication functions using connectors and association blocks. Information flows can be added to connectors. In this case, the flow specifies, what information is transmitted, and the connector and the type of the connector specify, how the information is transmitted. Association blocks can be used to precisely define the type of the connectors, the way the data is transmitted. Parts of the association block can be allocated to ports on lower abstraction levels. This way engineers can easily model, if an information flow goes through multiple components before reaching its destination. It is advantageous, to define the association block between an abstract block, and all the other blocks, among which the communication is specified, specialize the abstract block.","title":"SysML communication modeling"},{"location":"sysml-communication-modeling/#sysml-communication-modeling-using-stochastic-gamma","text":"DataType port rule: DataType can be used as a port classifier, which is equivalent if the port's classifier is an interface block, which has exactly one flow property. The type of the flow property is the data type and the direction of the flow property is \"out\". In any other rule, a DataType is used instead of an InterfaceBlock, then this rule shall be applied. InformationFlow rule: Information flows can be used to define that port connections. If an information flow connects two ports, then it is equivalent to the connection of the two ports. If one or both end of the information flow is connected to a part instead of a port, then the conveyed item and the name of the information flow specifies the type and the name of the port, respectively. The port shall be defined in the type of the part. The connection rules are the following: If the type of the part has only one port of which type equals to the conveyed item, then the port with the same type is chosen. If the type of part has multiple ports of which type equals to the conveyed item, then the port is chosen by its name. The name of the port and the name informtion flow must be equivalent. If an information flow contains multiple conveyed items then it is equivalent to multiple information flows, with the same name and with exactly one conveyed item of the items of the original information flow. Composite port rule: If more information flows are connected to a port, than it is equivalent to composite port connection. In this case the composite port contains has multiple subports, and their name and types are specified by the name and conveyed item of the information flow. Port transmission rule: The sub-ports of the type of ports can be allocated to other blocks, which specifies that the ports has internal 'boundary' parts. Communication path rule: One can use this modeling pattern to separate the communication modeling from the information flows. As a result, one can hide all the communication functions using connectors and association blocks. Information flows can be added to connectors. In this case, the flow specifies, what information is transmitted, and the connector and the type of the connector specify, how the information is transmitted. Association blocks can be used to precisely define the type of the connectors, the way the data is transmitted. Parts of the association block can be allocated to ports on lower abstraction levels. This way engineers can easily model, if an information flow goes through multiple components before reaching its destination. It is advantageous, to define the association block between an abstract block, and all the other blocks, among which the communication is specified, specialize the abstract block.","title":"SysML communication modeling using Stochastic Gamma"},{"location":"sysml-error-modeling/","text":"SysML dependability and performance modeling using Stochastic Gamma Profile of Extra-Functional Aspects This profile contains abstract stereotypes, which define abstract non-deterministic aspects. The model-transformation approaches and tools use only this profile. Stereotypes from other profiles can specialize the nondeterministic stereotypes. All other stereotype-related information is domain-specific and helps only for the engineers to handle and understand the models. The definitions of stereotypes are the following: - NondeterministicSignal : An instantaneous phenomenon, which is not part of the nominal, functional behavior of the system and the occurrence time of the phenomena cannot be predicted. - Attributes of the threat: The parameters of the threat occurrences. The actual value of the parameters is nondeterministic, cannot be predicted. - Threat: Threat specializes NondeterministicSignal. The phenomena directly or indirectly affect the dependability, performance or security of the system. - ExtraFunctionalAspect : The collection of threats and behaviors, which are related to a given type of extra-functional aspect. - Realization between aspect and classifier: The classifier has all attribute, reception and behavior of the aspect. - Signal receptions of the aspect: The list of threat, which belong to the given extra-functional aspect. - Constraint: The signal of the reception must be a threat. - Attributes of the aspect: The list of extra-functional attributes, which belong to the given extra-functional aspect. - ExtraFunctionalAspectBlock : The collection of threats and behaviors, which are related to a given type of extra-functional aspect. - Realization between aspect and block: The block has all flow properties, reception and behavior of the aspect. - Signal receptions of the aspect: The list of threat, which belong to the given extra-functional aspect. - Constraint: The signal of the reception must be a threat. - Flow properties of the aspect: The list of directed flowing items, which belong to the given extra-functional aspect and may affect the related system element. - ExtraFunctionalBehavior : This behavior specifies the behavior of system elements related to the given aspects. There are three types of extra functional behavior: extra-functional state machine, activity and opaque behavior. - ThreatConstraint : Vulnerability extends constraint metaclass. Vulnerability specifies what kind of conditions can cause the occurrence and activation of threats. Vulnerability specifies the constraints of threat occurrences, whether is it a transient or permanent and how many times the threat can occur. Profile of Dependability and Error behavior The ErrorModeling profile contains the dependability extension of the ExtraFunctionalAspects profile. The definitions of the stereotypes are the following: - Fault : Fault is the specialization of the abstract nondeterministic threat. A fault is an instantaneous phenomenon, which may cause the system or system components to malfunction and can be the root cause of other errors and failures. - Error : Error extends the state metaclass. Error is the state of a system element, which may lead to system failure. - Failure : Failure is the specialization of the abstract nondeterministic threat. Failure is an instantaneous event, when the system or a system element (i.e.: component, function, subsystem) transitions from a correct operation state into an incorrect one. - ErrorCondition : ErrorCondition specializes constraint metaclass. An ErrorCondition specifies an error, which occur if a given first order logic formula is true. An error condition can become true during the operation of the system and true condition means that the containing system element is in a given error state. ErrorCondition is introduced to define erroneous state and attribute valuation. ErrorCondition can be used instead of new parallel regions. - ErrorPropagationBehavior : ErrorPropagationBehavior specializes ExtraFunctionalBehavior stereotype. Error propagation behavior specifies, how a system element reacts to the failure of other system elements and the error can propagate. There are three types of error propagation behavior ErrorStatemachines, ErrorActivities and ErrotOpaqueBehaviors. - FaultConstraint : FaultConstraint specializes ThreatConstraint spereotype. Fault constraint defines when and how a fault can occur (i.e.: a random hardware fault occurs once and the occurrence time is exponentially distributed). - ErrorAspect : Error aspect specializes ExtraFunctionalAspect. Error aspect specifies the faults and failures of a system elements. - Realized ErrorAspect of an interface or interface blocks (an interface or an interface block is connected to an ErrorAspect with realization) specifies, what kind of failures can propagate through a given interface. - Used ErrorAspect of a component, function or subsystem specifies (a class or block is connected to an ErrorAspect with realization), what kind are its high-level failures, which may affect other components, which are allocated to the component/function/subsystem. - Realized ErrorAspect of a component, function or subsystem (class or block is connected to an ErrorAspect with realization) specifies, what kind of faults and failures can affect the state of the component, function or subsystem. If the ErrorAspects contains the receptions of failures, it means that if the system element is allocated to another system element and the system element produces this failure, than it failure of the component will affect the internal state of the original allocated component. - Attribute of ErrorAspect: It means that some dependability-related property of a system element may affect the dependability of other system elements. For instance, the integrity, availability and timeliness of a measurement can affect other parts of the system, which use this measurement. - ErrorAspectBlock : Error aspect specializes ExtraFunctionalAspectBlock. ErrorAspectBlock is similar to ErrorAspect, yet in error aspect block, flow properties can be used to model error propagation. - FlowProperty of ErrorAspectBlock: Similarly to the attribute of ErrorAspect, the flow property means that some dependability-related property of a system element may affect the dependability of other system elements. In contrast to attributes, flow properties may have multiple directions. - FlowProperty of ErrorAspectBlock: It means that some dependability-related property of a system element may affect the dependability of other system elements. For instance, the integrity, availability and timeliness of a measurement can affect other parts of the system, which use this measurement. Dependability and Performability Analysis of SysML models using Stochastic Gamma The suggested application of Stochastic Gamma is discussed in this section. The analysis approach consists of four major steps: 1.) Develop system architecture, 2.) Extra-functional modeling, 3.) Simulation-based Dependability Verification, and 4.) Developing Implementation Workproducts. The architectural design defines the system behavior on multiple abstraction layers, separating the physical components and subsystems from their logical role and functionality. Thereafter, both the functions, components, and interfaces are supplemented with extra-functional aspects specifying their timing, failure modes, and internal error propagation. The model-driven verification transforms the extended engineering models into a error propagation simulator and verify the dependability automatically. If the architecture does not satisfy the requirements, the design can be iterated. If the requirements are satisfied, then in the final step of the approach, implementation workproducts, such as software architecture, electrical schematics, mechanical design constraints, and test cases, can be developed using the system architecture. To analyze the extended dependability models, we transform the SysML engineering models into a low-level formal modeling language called Gamma. Thereafter, we use the simulation capabilities of Gamma to systematically simulate different malfunction scenarios and evaluate their high-level effect on the substation. Each malfunction scenario contains some failures of the protection-related components and ends with the occurrence of a high-voltage short-circuit. After the simulation of the failure scenario, the simulator is reset. Finally, our approach evaluates the malfunction scenarios to verify dependability requirements and find systematic weaknesses in the system architecture.","title":"SysML extra-functional modeling"},{"location":"sysml-error-modeling/#sysml-dependability-and-performance-modeling-using-stochastic-gamma","text":"","title":"SysML dependability and performance modeling using Stochastic Gamma"},{"location":"sysml-error-modeling/#profile-of-extra-functional-aspects","text":"This profile contains abstract stereotypes, which define abstract non-deterministic aspects. The model-transformation approaches and tools use only this profile. Stereotypes from other profiles can specialize the nondeterministic stereotypes. All other stereotype-related information is domain-specific and helps only for the engineers to handle and understand the models. The definitions of stereotypes are the following: - NondeterministicSignal : An instantaneous phenomenon, which is not part of the nominal, functional behavior of the system and the occurrence time of the phenomena cannot be predicted. - Attributes of the threat: The parameters of the threat occurrences. The actual value of the parameters is nondeterministic, cannot be predicted. - Threat: Threat specializes NondeterministicSignal. The phenomena directly or indirectly affect the dependability, performance or security of the system. - ExtraFunctionalAspect : The collection of threats and behaviors, which are related to a given type of extra-functional aspect. - Realization between aspect and classifier: The classifier has all attribute, reception and behavior of the aspect. - Signal receptions of the aspect: The list of threat, which belong to the given extra-functional aspect. - Constraint: The signal of the reception must be a threat. - Attributes of the aspect: The list of extra-functional attributes, which belong to the given extra-functional aspect. - ExtraFunctionalAspectBlock : The collection of threats and behaviors, which are related to a given type of extra-functional aspect. - Realization between aspect and block: The block has all flow properties, reception and behavior of the aspect. - Signal receptions of the aspect: The list of threat, which belong to the given extra-functional aspect. - Constraint: The signal of the reception must be a threat. - Flow properties of the aspect: The list of directed flowing items, which belong to the given extra-functional aspect and may affect the related system element. - ExtraFunctionalBehavior : This behavior specifies the behavior of system elements related to the given aspects. There are three types of extra functional behavior: extra-functional state machine, activity and opaque behavior. - ThreatConstraint : Vulnerability extends constraint metaclass. Vulnerability specifies what kind of conditions can cause the occurrence and activation of threats. Vulnerability specifies the constraints of threat occurrences, whether is it a transient or permanent and how many times the threat can occur.","title":"Profile of Extra-Functional Aspects"},{"location":"sysml-error-modeling/#profile-of-dependability-and-error-behavior","text":"The ErrorModeling profile contains the dependability extension of the ExtraFunctionalAspects profile. The definitions of the stereotypes are the following: - Fault : Fault is the specialization of the abstract nondeterministic threat. A fault is an instantaneous phenomenon, which may cause the system or system components to malfunction and can be the root cause of other errors and failures. - Error : Error extends the state metaclass. Error is the state of a system element, which may lead to system failure. - Failure : Failure is the specialization of the abstract nondeterministic threat. Failure is an instantaneous event, when the system or a system element (i.e.: component, function, subsystem) transitions from a correct operation state into an incorrect one. - ErrorCondition : ErrorCondition specializes constraint metaclass. An ErrorCondition specifies an error, which occur if a given first order logic formula is true. An error condition can become true during the operation of the system and true condition means that the containing system element is in a given error state. ErrorCondition is introduced to define erroneous state and attribute valuation. ErrorCondition can be used instead of new parallel regions. - ErrorPropagationBehavior : ErrorPropagationBehavior specializes ExtraFunctionalBehavior stereotype. Error propagation behavior specifies, how a system element reacts to the failure of other system elements and the error can propagate. There are three types of error propagation behavior ErrorStatemachines, ErrorActivities and ErrotOpaqueBehaviors. - FaultConstraint : FaultConstraint specializes ThreatConstraint spereotype. Fault constraint defines when and how a fault can occur (i.e.: a random hardware fault occurs once and the occurrence time is exponentially distributed). - ErrorAspect : Error aspect specializes ExtraFunctionalAspect. Error aspect specifies the faults and failures of a system elements. - Realized ErrorAspect of an interface or interface blocks (an interface or an interface block is connected to an ErrorAspect with realization) specifies, what kind of failures can propagate through a given interface. - Used ErrorAspect of a component, function or subsystem specifies (a class or block is connected to an ErrorAspect with realization), what kind are its high-level failures, which may affect other components, which are allocated to the component/function/subsystem. - Realized ErrorAspect of a component, function or subsystem (class or block is connected to an ErrorAspect with realization) specifies, what kind of faults and failures can affect the state of the component, function or subsystem. If the ErrorAspects contains the receptions of failures, it means that if the system element is allocated to another system element and the system element produces this failure, than it failure of the component will affect the internal state of the original allocated component. - Attribute of ErrorAspect: It means that some dependability-related property of a system element may affect the dependability of other system elements. For instance, the integrity, availability and timeliness of a measurement can affect other parts of the system, which use this measurement. - ErrorAspectBlock : Error aspect specializes ExtraFunctionalAspectBlock. ErrorAspectBlock is similar to ErrorAspect, yet in error aspect block, flow properties can be used to model error propagation. - FlowProperty of ErrorAspectBlock: Similarly to the attribute of ErrorAspect, the flow property means that some dependability-related property of a system element may affect the dependability of other system elements. In contrast to attributes, flow properties may have multiple directions. - FlowProperty of ErrorAspectBlock: It means that some dependability-related property of a system element may affect the dependability of other system elements. For instance, the integrity, availability and timeliness of a measurement can affect other parts of the system, which use this measurement.","title":"Profile of Dependability and Error behavior"},{"location":"sysml-error-modeling/#dependability-and-performability-analysis-of-sysml-models-using-stochastic-gamma","text":"The suggested application of Stochastic Gamma is discussed in this section. The analysis approach consists of four major steps: 1.) Develop system architecture, 2.) Extra-functional modeling, 3.) Simulation-based Dependability Verification, and 4.) Developing Implementation Workproducts. The architectural design defines the system behavior on multiple abstraction layers, separating the physical components and subsystems from their logical role and functionality. Thereafter, both the functions, components, and interfaces are supplemented with extra-functional aspects specifying their timing, failure modes, and internal error propagation. The model-driven verification transforms the extended engineering models into a error propagation simulator and verify the dependability automatically. If the architecture does not satisfy the requirements, the design can be iterated. If the requirements are satisfied, then in the final step of the approach, implementation workproducts, such as software architecture, electrical schematics, mechanical design constraints, and test cases, can be developed using the system architecture. To analyze the extended dependability models, we transform the SysML engineering models into a low-level formal modeling language called Gamma. Thereafter, we use the simulation capabilities of Gamma to systematically simulate different malfunction scenarios and evaluate their high-level effect on the substation. Each malfunction scenario contains some failures of the protection-related components and ends with the occurrence of a high-voltage short-circuit. After the simulation of the failure scenario, the simulator is reset. Finally, our approach evaluates the malfunction scenarios to verify dependability requirements and find systematic weaknesses in the system architecture.","title":"Dependability and Performability Analysis of SysML models using Stochastic Gamma"},{"location":"sysml-modeling/","text":"SysML modeling using Stochastic Gamma Core concepts This section presents the main modeling decisions, we made during the definition of the error metamodel. - Modularity and extensibility: Our objective was to create a universal approach, which can be used in multiple application domains with different terminologies. The nondeterministic, stochastic and extra-functional aspects are separated into interdependent UML profiles. The error behavior is a specific kind of nondeterministic behavior. During analysis, engineers can resolve the nondeterminism with stochastic models using industrial standards, accelerated aging tests and environmental profiles. - Extendable abstraction layer and allocation modeling: As the error propagation within distributed systems include software, electrical and mechanical behaviors simultaneously, we defined a modeling approach to define domain-specific abstraction layers (such as mechanical, software and functional modeling layers). Allocation among the modeling layers can define the traceability among the modeling elements, among the abstraction layers. In addition, extra-functional, threat propagation modeling patterns are defined to support the error propagation modeling across multiple abstraction layers (i.e.: if a microcontroller is faulty, then all software functions become faulty, which are allocated to the microcontroller). - View-based abstraction layer modeling: All abstraction layers are views with \"AbstractionLayer\" stereotype. If an abstraction layer exposes a package, then all classifier within the package belong to the given abstraction layer. If an abstraction layer exposes a profile, then all modeling elements, which has a stereotype from the profile belong to the abstraction layer. - Standard behavior semantics: Our objective was to define the extra-functional behavior of the components and functions (such as error propagation behavior within a component) using solely state-of-the-art statechart and activity semantics. All extra-functional behavior and error propagation formalisms are UML formalisms. Thus, engineers don't have to learn new execution semantics. Moreover, existing simulators can be used to evaluate the dependability models. - Signal-based threat modeling: The different types of threats, such as errors, faults and cyber attacks are stereotyped signals. As a result, we can use state-of-the-art UML-based behavior modeling approaches for specifying error propagation. For instance, error statemachines are UML statecharts, where the error states are marked with a stereotype, and component fault trees are activity diagrams, where AND and OR gates are join and merge nodes, with a custom stereotype and appearance. - UML and SysMLv1 support: The extra-functional stereotypes extend both UML metaclasses and SysMLv1 stereotypes, in order to support both SysMLv1 and domain-specific UML based modeling approaches. - Communication network support: To manage distributed fault-tolerance solutions, the modeling approach includes a modeling extension for communication modeling, independently from the extra-functional models. The communication modeling approach enables engineers to use information flows, association blocks and full ports for concise and transparent modeling. The communication modeling approach defines intuitive modelling patterns, to separate the low-level communication channel definitions from the high-level functional and application models.","title":"SysML dependability modeling"},{"location":"sysml-modeling/#sysml-modeling-using-stochastic-gamma","text":"","title":"SysML modeling using Stochastic Gamma"},{"location":"sysml-modeling/#core-concepts","text":"This section presents the main modeling decisions, we made during the definition of the error metamodel. - Modularity and extensibility: Our objective was to create a universal approach, which can be used in multiple application domains with different terminologies. The nondeterministic, stochastic and extra-functional aspects are separated into interdependent UML profiles. The error behavior is a specific kind of nondeterministic behavior. During analysis, engineers can resolve the nondeterminism with stochastic models using industrial standards, accelerated aging tests and environmental profiles. - Extendable abstraction layer and allocation modeling: As the error propagation within distributed systems include software, electrical and mechanical behaviors simultaneously, we defined a modeling approach to define domain-specific abstraction layers (such as mechanical, software and functional modeling layers). Allocation among the modeling layers can define the traceability among the modeling elements, among the abstraction layers. In addition, extra-functional, threat propagation modeling patterns are defined to support the error propagation modeling across multiple abstraction layers (i.e.: if a microcontroller is faulty, then all software functions become faulty, which are allocated to the microcontroller). - View-based abstraction layer modeling: All abstraction layers are views with \"AbstractionLayer\" stereotype. If an abstraction layer exposes a package, then all classifier within the package belong to the given abstraction layer. If an abstraction layer exposes a profile, then all modeling elements, which has a stereotype from the profile belong to the abstraction layer. - Standard behavior semantics: Our objective was to define the extra-functional behavior of the components and functions (such as error propagation behavior within a component) using solely state-of-the-art statechart and activity semantics. All extra-functional behavior and error propagation formalisms are UML formalisms. Thus, engineers don't have to learn new execution semantics. Moreover, existing simulators can be used to evaluate the dependability models. - Signal-based threat modeling: The different types of threats, such as errors, faults and cyber attacks are stereotyped signals. As a result, we can use state-of-the-art UML-based behavior modeling approaches for specifying error propagation. For instance, error statemachines are UML statecharts, where the error states are marked with a stereotype, and component fault trees are activity diagrams, where AND and OR gates are join and merge nodes, with a custom stereotype and appearance. - UML and SysMLv1 support: The extra-functional stereotypes extend both UML metaclasses and SysMLv1 stereotypes, in order to support both SysMLv1 and domain-specific UML based modeling approaches. - Communication network support: To manage distributed fault-tolerance solutions, the modeling approach includes a modeling extension for communication modeling, independently from the extra-functional models. The communication modeling approach enables engineers to use information flows, association blocks and full ports for concise and transparent modeling. The communication modeling approach defines intuitive modelling patterns, to separate the low-level communication channel definitions from the high-level functional and application models.","title":"Core concepts"},{"location":"sysml-variant-modeling/","text":"SysML variant modeling using Stochastic Gamma The SysML-based dependability modeling of Stochastic Gamma fully support the modified VAMOS variant modeling tool. The variant handling extension of Enterprise Architect is available here: LINK . The main concepts of variability modeling are built on the top of generalization and redefine sematics. Variant Modeling Profile This sections presents the modeling elements of the modified VAMOS approach for the better understanding. Variation point : A variation point is an element of the model where the variants differ. The variation point represents a place (structural modelling) or role (behavioural modelling), which shall be filled later by the configured variant. To every variation point, a set of variants, a variation shall be connected. The connected variation collects the candidate components that can later fill the role. Variant : A variant is a model element. A variant is developed based on an interface given by the implemented variation point. It encloses the properties which distinguish variants of the model from each other. This difference can be the used algorithm or physical properties like operating voltage or temperature. The only limitation is that the variant must realize the interface defined in the variation the variant is part of. In special cases, for example, when a variant is used to declare that the component is not used in the configuration, properties of a variation point can be redefined. If a model element is a variant, the contained model elements are also part of the variant by default. Configuration : A configuration is always connected to one specific model, called a system model. A configuration is a map where the map\u2019s keys are the system model\u2019s variation points. The values of the map are variants. For every key-value pair, the variant must be part of the variation connected to the variation point. A configuration can be complete if all of the system model\u2019s variation points are part of the configuration. A configuration is a partial configuration if some, but not all, of the system model\u2019s variation point is part of the configuration. Variation : A variant is a model element. A variant is developed based on an interface given by the implemented variation point. It encloses the properties which distinguish variants of the model from each other. This difference can be the used algorithm or physical properties like operating voltage or temperature. The only limitation is that the variant must realize the interface defined in the variation the variant is part of. In special cases, for example, when a variant is used to declare that the component is not used in the configuration, properties of a variation point can be redefined. If a model element is a variant, the contained model elements are also part of the variant by default. Variation : Variant Modeling of Variants The variability modeling extends the UML's generalization and redefine relationships with additional variant-specific attributes. The error models are handled as standard SysML and UML behavior and interface models. - Extra-functional aspects and aspects of variants: If two variants generalize each other then the specialized variant will inherit the generalized variant. - Extra-functional aspects and aspects of variants and variation points: If a variation point has a variation point realizes or uses an extra-functional aspect, then all of its variants will inherit the aspect. - Extra-functional behavior of variants: Variation points cannot contain extra-functional behavior. Only variants can have extra-functional behavior. If two variants generalize each other and the generalized variant have extra-functional bahavior and the specialized does have none, then the specialized variant will inherit the extra-functional behavior of the generalized variant.","title":"SysML variant modeling"},{"location":"sysml-variant-modeling/#sysml-variant-modeling-using-stochastic-gamma","text":"The SysML-based dependability modeling of Stochastic Gamma fully support the modified VAMOS variant modeling tool. The variant handling extension of Enterprise Architect is available here: LINK . The main concepts of variability modeling are built on the top of generalization and redefine sematics.","title":"SysML variant modeling using Stochastic Gamma"},{"location":"sysml-variant-modeling/#variant-modeling-profile","text":"This sections presents the modeling elements of the modified VAMOS approach for the better understanding. Variation point : A variation point is an element of the model where the variants differ. The variation point represents a place (structural modelling) or role (behavioural modelling), which shall be filled later by the configured variant. To every variation point, a set of variants, a variation shall be connected. The connected variation collects the candidate components that can later fill the role. Variant : A variant is a model element. A variant is developed based on an interface given by the implemented variation point. It encloses the properties which distinguish variants of the model from each other. This difference can be the used algorithm or physical properties like operating voltage or temperature. The only limitation is that the variant must realize the interface defined in the variation the variant is part of. In special cases, for example, when a variant is used to declare that the component is not used in the configuration, properties of a variation point can be redefined. If a model element is a variant, the contained model elements are also part of the variant by default. Configuration : A configuration is always connected to one specific model, called a system model. A configuration is a map where the map\u2019s keys are the system model\u2019s variation points. The values of the map are variants. For every key-value pair, the variant must be part of the variation connected to the variation point. A configuration can be complete if all of the system model\u2019s variation points are part of the configuration. A configuration is a partial configuration if some, but not all, of the system model\u2019s variation point is part of the configuration. Variation : A variant is a model element. A variant is developed based on an interface given by the implemented variation point. It encloses the properties which distinguish variants of the model from each other. This difference can be the used algorithm or physical properties like operating voltage or temperature. The only limitation is that the variant must realize the interface defined in the variation the variant is part of. In special cases, for example, when a variant is used to declare that the component is not used in the configuration, properties of a variation point can be redefined. If a model element is a variant, the contained model elements are also part of the variant by default. Variation :","title":"Variant Modeling Profile"},{"location":"sysml-variant-modeling/#variant-modeling-of-variants","text":"The variability modeling extends the UML's generalization and redefine relationships with additional variant-specific attributes. The error models are handled as standard SysML and UML behavior and interface models. - Extra-functional aspects and aspects of variants: If two variants generalize each other then the specialized variant will inherit the generalized variant. - Extra-functional aspects and aspects of variants and variation points: If a variation point has a variation point realizes or uses an extra-functional aspect, then all of its variants will inherit the aspect. - Extra-functional behavior of variants: Variation points cannot contain extra-functional behavior. Only variants can have extra-functional behavior. If two variants generalize each other and the generalized variant have extra-functional bahavior and the specialized does have none, then the specialized variant will inherit the extra-functional behavior of the generalized variant.","title":"Variant Modeling of Variants"}]}