/*
 * generated by Xtext 2.30.0.M2
 */
package hu.bme.mit.gamma.environment.language.serializer;

import com.google.inject.Inject;
import hu.bme.mit.gamma.action.model.ActionModelPackage;
import hu.bme.mit.gamma.action.model.AssertionStatement;
import hu.bme.mit.gamma.action.model.AssignmentStatement;
import hu.bme.mit.gamma.action.model.Block;
import hu.bme.mit.gamma.action.model.Branch;
import hu.bme.mit.gamma.action.model.BreakStatement;
import hu.bme.mit.gamma.action.model.ChoiceStatement;
import hu.bme.mit.gamma.action.model.ConstantDeclarationStatement;
import hu.bme.mit.gamma.action.model.EmptyStatement;
import hu.bme.mit.gamma.action.model.ExpressionStatement;
import hu.bme.mit.gamma.action.model.ForStatement;
import hu.bme.mit.gamma.action.model.IfStatement;
import hu.bme.mit.gamma.action.model.ProcedureDeclaration;
import hu.bme.mit.gamma.action.model.ReturnStatement;
import hu.bme.mit.gamma.action.model.SwitchStatement;
import hu.bme.mit.gamma.action.model.VariableDeclarationStatement;
import hu.bme.mit.gamma.environment.analysis.AnalysisComponent;
import hu.bme.mit.gamma.environment.analysis.AnalysisPackage;
import hu.bme.mit.gamma.environment.analysis.AssumeNotRaised;
import hu.bme.mit.gamma.environment.analysis.AssumeRaised;
import hu.bme.mit.gamma.environment.analysis.ComponentPortEventReference;
import hu.bme.mit.gamma.environment.analysis.EndCondition;
import hu.bme.mit.gamma.environment.analysis.EventTimeRatio;
import hu.bme.mit.gamma.environment.analysis.Frequency;
import hu.bme.mit.gamma.environment.analysis.HMC;
import hu.bme.mit.gamma.environment.analysis.ImportanceSampling;
import hu.bme.mit.gamma.environment.analysis.MCMC;
import hu.bme.mit.gamma.environment.analysis.MeanParameter;
import hu.bme.mit.gamma.environment.analysis.MeanTime;
import hu.bme.mit.gamma.environment.analysis.MeanTimeBetweenEvents;
import hu.bme.mit.gamma.environment.analysis.NUTS;
import hu.bme.mit.gamma.environment.analysis.ObserveParameter;
import hu.bme.mit.gamma.environment.analysis.ObserveTime;
import hu.bme.mit.gamma.environment.analysis.ParameterDistribution;
import hu.bme.mit.gamma.environment.analysis.PrioryDistribution;
import hu.bme.mit.gamma.environment.analysis.Probability;
import hu.bme.mit.gamma.environment.analysis.RecursiveComponentReference;
import hu.bme.mit.gamma.environment.analysis.TimeBoundedProbability;
import hu.bme.mit.gamma.environment.analysis.TimedProbability;
import hu.bme.mit.gamma.environment.language.services.EnvironmentLanguageGrammarAccess;
import hu.bme.mit.gamma.environment.model.ComponentFilter;
import hu.bme.mit.gamma.environment.model.EnvironmentAsynchronousCompositeComponent;
import hu.bme.mit.gamma.environment.model.EnvironmentAsynchronousCompositeComponentInstance;
import hu.bme.mit.gamma.environment.model.EnvironmentCascadeCompositeComponent;
import hu.bme.mit.gamma.environment.model.EnvironmentDelay;
import hu.bme.mit.gamma.environment.model.EnvironmentEventSource;
import hu.bme.mit.gamma.environment.model.EnvironmentExternSimulation;
import hu.bme.mit.gamma.environment.model.EnvironmentModelPackage;
import hu.bme.mit.gamma.environment.model.EnvironmentPeriodicEventSource;
import hu.bme.mit.gamma.environment.model.EnvironmentSample;
import hu.bme.mit.gamma.environment.model.EnvironmentSwitch;
import hu.bme.mit.gamma.environment.model.EnvironmentSynchronousCompositeComponent;
import hu.bme.mit.gamma.environment.model.EventFilter;
import hu.bme.mit.gamma.environment.model.ParameterFilter;
import hu.bme.mit.gamma.environment.model.PortFilter;
import hu.bme.mit.gamma.environment.model.Simulation;
import hu.bme.mit.gamma.environment.model.SimulationRule;
import hu.bme.mit.gamma.environment.model.StochasticRule;
import hu.bme.mit.gamma.environment.stochastic.stochastic.BernoulliRandomVariable;
import hu.bme.mit.gamma.environment.stochastic.stochastic.BetaRandomVariable;
import hu.bme.mit.gamma.environment.stochastic.stochastic.BrownianKernel;
import hu.bme.mit.gamma.environment.stochastic.stochastic.CategoricalProbabaility;
import hu.bme.mit.gamma.environment.stochastic.stochastic.DiracProcess;
import hu.bme.mit.gamma.environment.stochastic.stochastic.ExponentialRandomVariable;
import hu.bme.mit.gamma.environment.stochastic.stochastic.FittedExponentialRandomVariable;
import hu.bme.mit.gamma.environment.stochastic.stochastic.FittedGammaRandomVariable;
import hu.bme.mit.gamma.environment.stochastic.stochastic.FittedGaussianProcess;
import hu.bme.mit.gamma.environment.stochastic.stochastic.FittedNormalRandomVariable;
import hu.bme.mit.gamma.environment.stochastic.stochastic.GammaRandomVariable;
import hu.bme.mit.gamma.environment.stochastic.stochastic.InfluxDB;
import hu.bme.mit.gamma.environment.stochastic.stochastic.LinearKernel;
import hu.bme.mit.gamma.environment.stochastic.stochastic.LogNormalRandomVariable;
import hu.bme.mit.gamma.environment.stochastic.stochastic.NormalRandomVariable;
import hu.bme.mit.gamma.environment.stochastic.stochastic.ParetoRandomVariable;
import hu.bme.mit.gamma.environment.stochastic.stochastic.PeriodicKernel;
import hu.bme.mit.gamma.environment.stochastic.stochastic.PythonSimulation;
import hu.bme.mit.gamma.environment.stochastic.stochastic.RBFKernel;
import hu.bme.mit.gamma.environment.stochastic.stochastic.StochasticExpression;
import hu.bme.mit.gamma.environment.stochastic.stochastic.StochasticPackage;
import hu.bme.mit.gamma.environment.stochastic.stochastic.SumKernel;
import hu.bme.mit.gamma.environment.stochastic.stochastic.UniformRandomVariable;
import hu.bme.mit.gamma.environment.stochastic.stochastic.WeibullRandomVariable;
import hu.bme.mit.gamma.expression.model.AddExpression;
import hu.bme.mit.gamma.expression.model.AndExpression;
import hu.bme.mit.gamma.expression.model.ArrayAccessExpression;
import hu.bme.mit.gamma.expression.model.ArrayLiteralExpression;
import hu.bme.mit.gamma.expression.model.ArrayTypeDefinition;
import hu.bme.mit.gamma.expression.model.BasicConstraintDefinition;
import hu.bme.mit.gamma.expression.model.BooleanTypeDefinition;
import hu.bme.mit.gamma.expression.model.ConstantDeclaration;
import hu.bme.mit.gamma.expression.model.DecimalLiteralExpression;
import hu.bme.mit.gamma.expression.model.DecimalTypeDefinition;
import hu.bme.mit.gamma.expression.model.DefaultExpression;
import hu.bme.mit.gamma.expression.model.DirectReferenceExpression;
import hu.bme.mit.gamma.expression.model.DivExpression;
import hu.bme.mit.gamma.expression.model.DivideExpression;
import hu.bme.mit.gamma.expression.model.ElseExpression;
import hu.bme.mit.gamma.expression.model.EnumerationLiteralDefinition;
import hu.bme.mit.gamma.expression.model.EnumerationLiteralExpression;
import hu.bme.mit.gamma.expression.model.EnumerationTypeDefinition;
import hu.bme.mit.gamma.expression.model.EqualityExpression;
import hu.bme.mit.gamma.expression.model.ExistsExpression;
import hu.bme.mit.gamma.expression.model.ExpressionModelPackage;
import hu.bme.mit.gamma.expression.model.ExpressionPackage;
import hu.bme.mit.gamma.expression.model.FalseExpression;
import hu.bme.mit.gamma.expression.model.FieldAssignment;
import hu.bme.mit.gamma.expression.model.FieldDeclaration;
import hu.bme.mit.gamma.expression.model.FieldReferenceExpression;
import hu.bme.mit.gamma.expression.model.ForallExpression;
import hu.bme.mit.gamma.expression.model.FunctionAccessExpression;
import hu.bme.mit.gamma.expression.model.FunctionTypeDefinition;
import hu.bme.mit.gamma.expression.model.GreaterEqualExpression;
import hu.bme.mit.gamma.expression.model.GreaterExpression;
import hu.bme.mit.gamma.expression.model.IfThenElseExpression;
import hu.bme.mit.gamma.expression.model.ImplyExpression;
import hu.bme.mit.gamma.expression.model.InequalityExpression;
import hu.bme.mit.gamma.expression.model.InfinityExpression;
import hu.bme.mit.gamma.expression.model.IntegerLiteralExpression;
import hu.bme.mit.gamma.expression.model.IntegerRangeLiteralExpression;
import hu.bme.mit.gamma.expression.model.IntegerRangeTypeDefinition;
import hu.bme.mit.gamma.expression.model.IntegerTypeDefinition;
import hu.bme.mit.gamma.expression.model.LambdaDeclaration;
import hu.bme.mit.gamma.expression.model.LessEqualExpression;
import hu.bme.mit.gamma.expression.model.LessExpression;
import hu.bme.mit.gamma.expression.model.ModExpression;
import hu.bme.mit.gamma.expression.model.MultiplyExpression;
import hu.bme.mit.gamma.expression.model.NotExpression;
import hu.bme.mit.gamma.expression.model.OpaqueExpression;
import hu.bme.mit.gamma.expression.model.OrExpression;
import hu.bme.mit.gamma.expression.model.ParameterDeclaration;
import hu.bme.mit.gamma.expression.model.RationalLiteralExpression;
import hu.bme.mit.gamma.expression.model.RationalTypeDefinition;
import hu.bme.mit.gamma.expression.model.RecordAccessExpression;
import hu.bme.mit.gamma.expression.model.RecordLiteralExpression;
import hu.bme.mit.gamma.expression.model.RecordTypeDefinition;
import hu.bme.mit.gamma.expression.model.ResettableVariableDeclarationAnnotation;
import hu.bme.mit.gamma.expression.model.SelectExpression;
import hu.bme.mit.gamma.expression.model.SubrangeTypeDefinition;
import hu.bme.mit.gamma.expression.model.SubtractExpression;
import hu.bme.mit.gamma.expression.model.TransientVariableDeclarationAnnotation;
import hu.bme.mit.gamma.expression.model.TrueExpression;
import hu.bme.mit.gamma.expression.model.TypeDeclaration;
import hu.bme.mit.gamma.expression.model.TypeReference;
import hu.bme.mit.gamma.expression.model.UnaryMinusExpression;
import hu.bme.mit.gamma.expression.model.UnaryPlusExpression;
import hu.bme.mit.gamma.expression.model.UnremovableVariableDeclarationAnnotation;
import hu.bme.mit.gamma.expression.model.VariableDeclaration;
import hu.bme.mit.gamma.expression.model.VoidTypeDefinition;
import hu.bme.mit.gamma.expression.model.XorExpression;
import hu.bme.mit.gamma.statechart.composite.AsynchronousAdapter;
import hu.bme.mit.gamma.statechart.composite.AsynchronousComponentInstance;
import hu.bme.mit.gamma.statechart.composite.AsynchronousCompositeComponent;
import hu.bme.mit.gamma.statechart.composite.BroadcastChannel;
import hu.bme.mit.gamma.statechart.composite.CascadeCompositeComponent;
import hu.bme.mit.gamma.statechart.composite.ComponentInstanceEventParameterReferenceExpression;
import hu.bme.mit.gamma.statechart.composite.ComponentInstanceEventReferenceExpression;
import hu.bme.mit.gamma.statechart.composite.ComponentInstanceReferenceExpression;
import hu.bme.mit.gamma.statechart.composite.ComponentInstanceStateReferenceExpression;
import hu.bme.mit.gamma.statechart.composite.ComponentInstanceVariableReferenceExpression;
import hu.bme.mit.gamma.statechart.composite.CompositeModelPackage;
import hu.bme.mit.gamma.statechart.composite.ControlSpecification;
import hu.bme.mit.gamma.statechart.composite.EventPassing;
import hu.bme.mit.gamma.statechart.composite.InstancePortReference;
import hu.bme.mit.gamma.statechart.composite.MessageQueue;
import hu.bme.mit.gamma.statechart.composite.PortBinding;
import hu.bme.mit.gamma.statechart.composite.ScheduledAsynchronousCompositeComponent;
import hu.bme.mit.gamma.statechart.composite.SimpleChannel;
import hu.bme.mit.gamma.statechart.composite.SynchronousComponentInstance;
import hu.bme.mit.gamma.statechart.composite.SynchronousCompositeComponent;
import hu.bme.mit.gamma.statechart.contract.AdaptiveContractAnnotation;
import hu.bme.mit.gamma.statechart.contract.ContractModelPackage;
import hu.bme.mit.gamma.statechart.contract.HasInitialOutputsBlockAnnotation;
import hu.bme.mit.gamma.statechart.contract.NegativeContractStatechartAnnotation;
import hu.bme.mit.gamma.statechart.contract.ScenarioAllowedWaitAnnotation;
import hu.bme.mit.gamma.statechart.contract.ScenarioContractAnnotation;
import hu.bme.mit.gamma.statechart.contract.SpecialStateAnnotation;
import hu.bme.mit.gamma.statechart.contract.StateContractAnnotation;
import hu.bme.mit.gamma.statechart.interface_.AnyTrigger;
import hu.bme.mit.gamma.statechart.interface_.Clock;
import hu.bme.mit.gamma.statechart.interface_.Event;
import hu.bme.mit.gamma.statechart.interface_.EventDeclaration;
import hu.bme.mit.gamma.statechart.interface_.EventParameterReferenceExpression;
import hu.bme.mit.gamma.statechart.interface_.EventTrigger;
import hu.bme.mit.gamma.statechart.interface_.Interface;
import hu.bme.mit.gamma.statechart.interface_.InterfaceModelPackage;
import hu.bme.mit.gamma.statechart.interface_.InterfaceRealization;
import hu.bme.mit.gamma.statechart.interface_.Port;
import hu.bme.mit.gamma.statechart.interface_.TimeSpecification;
import hu.bme.mit.gamma.statechart.interface_.WrapperComponentAnnotation;
import hu.bme.mit.gamma.statechart.language.serializer.StatechartLanguageSemanticSequencer;
import hu.bme.mit.gamma.statechart.phase.InstanceVariableReference;
import hu.bme.mit.gamma.statechart.phase.MissionPhaseAnnotation;
import hu.bme.mit.gamma.statechart.phase.MissionPhaseStateAnnotation;
import hu.bme.mit.gamma.statechart.phase.PhaseModelPackage;
import hu.bme.mit.gamma.statechart.phase.VariableBinding;
import hu.bme.mit.gamma.statechart.statechart.AnyPortEventReference;
import hu.bme.mit.gamma.statechart.statechart.AsynchronousStatechartDefinition;
import hu.bme.mit.gamma.statechart.statechart.BinaryTrigger;
import hu.bme.mit.gamma.statechart.statechart.ChoiceState;
import hu.bme.mit.gamma.statechart.statechart.ClockTickReference;
import hu.bme.mit.gamma.statechart.statechart.DeactivateTimeoutAction;
import hu.bme.mit.gamma.statechart.statechart.DeepHistoryState;
import hu.bme.mit.gamma.statechart.statechart.ForkState;
import hu.bme.mit.gamma.statechart.statechart.InitialState;
import hu.bme.mit.gamma.statechart.statechart.JoinState;
import hu.bme.mit.gamma.statechart.statechart.MergeState;
import hu.bme.mit.gamma.statechart.statechart.OnCycleTrigger;
import hu.bme.mit.gamma.statechart.statechart.OpaqueTrigger;
import hu.bme.mit.gamma.statechart.statechart.PortEventReference;
import hu.bme.mit.gamma.statechart.statechart.RaiseEventAction;
import hu.bme.mit.gamma.statechart.statechart.Region;
import hu.bme.mit.gamma.statechart.statechart.RunUponExternalEventAnnotation;
import hu.bme.mit.gamma.statechart.statechart.SetTimeoutAction;
import hu.bme.mit.gamma.statechart.statechart.ShallowHistoryState;
import hu.bme.mit.gamma.statechart.statechart.State;
import hu.bme.mit.gamma.statechart.statechart.StateReferenceExpression;
import hu.bme.mit.gamma.statechart.statechart.StatechartModelPackage;
import hu.bme.mit.gamma.statechart.statechart.SynchronousStatechartDefinition;
import hu.bme.mit.gamma.statechart.statechart.TimeoutDeclaration;
import hu.bme.mit.gamma.statechart.statechart.TimeoutEventReference;
import hu.bme.mit.gamma.statechart.statechart.Transition;
import hu.bme.mit.gamma.statechart.statechart.TransitionIdAnnotation;
import hu.bme.mit.gamma.statechart.statechart.UnaryTrigger;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class EnvironmentLanguageSemanticSequencer extends StatechartLanguageSemanticSequencer {

	@Inject
	private EnvironmentLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AnalysisPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AnalysisPackage.ANALYSIS_COMPONENT:
				sequence_AnalysisComponent(context, (AnalysisComponent) semanticObject); 
				return; 
			case AnalysisPackage.ASSUME_NOT_RAISED:
				sequence_AssumeNotRaised(context, (AssumeNotRaised) semanticObject); 
				return; 
			case AnalysisPackage.ASSUME_RAISED:
				sequence_AssumeRaised(context, (AssumeRaised) semanticObject); 
				return; 
			case AnalysisPackage.COMPONENT_PORT_EVENT_REFERENCE:
				sequence_ComponentPortEventReference(context, (ComponentPortEventReference) semanticObject); 
				return; 
			case AnalysisPackage.END_CONDITION:
				sequence_EndCondition(context, (EndCondition) semanticObject); 
				return; 
			case AnalysisPackage.EVENT_TIME_RATIO:
				sequence_EventTimeRatio(context, (EventTimeRatio) semanticObject); 
				return; 
			case AnalysisPackage.FREQUENCY:
				sequence_Frequency(context, (Frequency) semanticObject); 
				return; 
			case AnalysisPackage.HMC:
				sequence_HMC(context, (HMC) semanticObject); 
				return; 
			case AnalysisPackage.IMPORTANCE_SAMPLING:
				sequence_ImportanceSampling(context, (ImportanceSampling) semanticObject); 
				return; 
			case AnalysisPackage.MCMC:
				sequence_MCMC(context, (MCMC) semanticObject); 
				return; 
			case AnalysisPackage.MEAN_PARAMETER:
				sequence_MeanParameter(context, (MeanParameter) semanticObject); 
				return; 
			case AnalysisPackage.MEAN_TIME:
				sequence_MeanTime(context, (MeanTime) semanticObject); 
				return; 
			case AnalysisPackage.MEAN_TIME_BETWEEN_EVENTS:
				sequence_MeanTimeBetweenEvents(context, (MeanTimeBetweenEvents) semanticObject); 
				return; 
			case AnalysisPackage.NUTS:
				sequence_NUTS(context, (NUTS) semanticObject); 
				return; 
			case AnalysisPackage.OBSERVE_PARAMETER:
				sequence_ObserveParameter(context, (ObserveParameter) semanticObject); 
				return; 
			case AnalysisPackage.OBSERVE_TIME:
				sequence_ObserveTime(context, (ObserveTime) semanticObject); 
				return; 
			case AnalysisPackage.PARAMETER_DISTRIBUTION:
				sequence_ParameterDistribution(context, (ParameterDistribution) semanticObject); 
				return; 
			case AnalysisPackage.PRIORY_DISTRIBUTION:
				sequence_PrioryDistribution(context, (PrioryDistribution) semanticObject); 
				return; 
			case AnalysisPackage.PROBABILITY:
				sequence_Probability(context, (Probability) semanticObject); 
				return; 
			case AnalysisPackage.RECURSIVE_COMPONENT_REFERENCE:
				sequence_RecursiveComponentReference(context, (RecursiveComponentReference) semanticObject); 
				return; 
			case AnalysisPackage.TIME_BOUNDED_PROBABILITY:
				sequence_TimeBoundedProbability(context, (TimeBoundedProbability) semanticObject); 
				return; 
			case AnalysisPackage.TIMED_PROBABILITY:
				sequence_TimedProbability(context, (TimedProbability) semanticObject); 
				return; 
			}
		else if (epackage == CompositeModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CompositeModelPackage.ASYNCHRONOUS_ADAPTER:
				sequence_AsynchronousAdapter(context, (AsynchronousAdapter) semanticObject); 
				return; 
			case CompositeModelPackage.ASYNCHRONOUS_COMPONENT_INSTANCE:
				sequence_AsynchronousComponentInstance(context, (AsynchronousComponentInstance) semanticObject); 
				return; 
			case CompositeModelPackage.ASYNCHRONOUS_COMPOSITE_COMPONENT:
				sequence_AsynchronousCompositeComponent(context, (AsynchronousCompositeComponent) semanticObject); 
				return; 
			case CompositeModelPackage.BROADCAST_CHANNEL:
				sequence_BroadcastChannel(context, (BroadcastChannel) semanticObject); 
				return; 
			case CompositeModelPackage.CASCADE_COMPOSITE_COMPONENT:
				sequence_CascadeCompositeComponent(context, (CascadeCompositeComponent) semanticObject); 
				return; 
			case CompositeModelPackage.COMPONENT_INSTANCE_EVENT_PARAMETER_REFERENCE_EXPRESSION:
				sequence_ComponentInstanceEventParameterReferenceExpression(context, (ComponentInstanceEventParameterReferenceExpression) semanticObject); 
				return; 
			case CompositeModelPackage.COMPONENT_INSTANCE_EVENT_REFERENCE_EXPRESSION:
				sequence_ComponentInstanceEventReferenceExpression(context, (ComponentInstanceEventReferenceExpression) semanticObject); 
				return; 
			case CompositeModelPackage.COMPONENT_INSTANCE_REFERENCE_EXPRESSION:
				if (rule == grammarAccess.getAtomicComponentInstanceReferenceExpressionRule()) {
					sequence_AtomicComponentInstanceReferenceExpression(context, (ComponentInstanceReferenceExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getComponentInstanceReferenceExpressionRule()) {
					sequence_ComponentInstanceReferenceExpression(context, (ComponentInstanceReferenceExpression) semanticObject); 
					return; 
				}
				else break;
			case CompositeModelPackage.COMPONENT_INSTANCE_STATE_REFERENCE_EXPRESSION:
				sequence_ComponentInstanceStateReferenceExpression(context, (ComponentInstanceStateReferenceExpression) semanticObject); 
				return; 
			case CompositeModelPackage.COMPONENT_INSTANCE_VARIABLE_REFERENCE_EXPRESSION:
				sequence_ComponentInstanceVariableReferenceExpression(context, (ComponentInstanceVariableReferenceExpression) semanticObject); 
				return; 
			case CompositeModelPackage.CONTROL_SPECIFICATION:
				sequence_ControlSpecificaiton(context, (ControlSpecification) semanticObject); 
				return; 
			case CompositeModelPackage.EVENT_PASSING:
				sequence_EventPassing(context, (EventPassing) semanticObject); 
				return; 
			case CompositeModelPackage.INSTANCE_PORT_REFERENCE:
				sequence_InstancePortReference(context, (InstancePortReference) semanticObject); 
				return; 
			case CompositeModelPackage.MESSAGE_QUEUE:
				sequence_MessageQueue(context, (MessageQueue) semanticObject); 
				return; 
			case CompositeModelPackage.PORT_BINDING:
				sequence_PortBinding(context, (PortBinding) semanticObject); 
				return; 
			case CompositeModelPackage.SCHEDULED_ASYNCHRONOUS_COMPOSITE_COMPONENT:
				sequence_ScheduledAsynchronousCompositeComponent(context, (ScheduledAsynchronousCompositeComponent) semanticObject); 
				return; 
			case CompositeModelPackage.SIMPLE_CHANNEL:
				sequence_SimpleChannel(context, (SimpleChannel) semanticObject); 
				return; 
			case CompositeModelPackage.SYNCHRONOUS_COMPONENT_INSTANCE:
				sequence_SynchronousComponentInstance(context, (SynchronousComponentInstance) semanticObject); 
				return; 
			case CompositeModelPackage.SYNCHRONOUS_COMPOSITE_COMPONENT:
				sequence_SynchronousCompositeComponent(context, (SynchronousCompositeComponent) semanticObject); 
				return; 
			}
		else if (epackage == ContractModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ContractModelPackage.ADAPTIVE_CONTRACT_ANNOTATION:
				sequence_AdaptiveContractAnnotation(context, (AdaptiveContractAnnotation) semanticObject); 
				return; 
			case ContractModelPackage.HAS_INITIAL_OUTPUTS_BLOCK_ANNOTATION:
				sequence_HasInitialoutputsBlockAnnotation(context, (HasInitialOutputsBlockAnnotation) semanticObject); 
				return; 
			case ContractModelPackage.NEGATIVE_CONTRACT_STATECHART_ANNOTATION:
				sequence_NegativeContractStatechartAnnotation(context, (NegativeContractStatechartAnnotation) semanticObject); 
				return; 
			case ContractModelPackage.SCENARIO_ALLOWED_WAIT_ANNOTATION:
				sequence_ScenarioAllowedWaitingAnnotation(context, (ScenarioAllowedWaitAnnotation) semanticObject); 
				return; 
			case ContractModelPackage.SCENARIO_CONTRACT_ANNOTATION:
				sequence_ScenarioContractAnnotation(context, (ScenarioContractAnnotation) semanticObject); 
				return; 
			case ContractModelPackage.SPECIAL_STATE_ANNOTATION:
				sequence_SpecialStateAnnotation(context, (SpecialStateAnnotation) semanticObject); 
				return; 
			case ContractModelPackage.STATE_CONTRACT_ANNOTATION:
				sequence_StateContractAnnotation(context, (StateContractAnnotation) semanticObject); 
				return; 
			}
		else if (epackage == InterfaceModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case InterfaceModelPackage.ANY_TRIGGER:
				sequence_AnyTrigger(context, (AnyTrigger) semanticObject); 
				return; 
			case InterfaceModelPackage.CLOCK:
				sequence_ClockDeclaration(context, (Clock) semanticObject); 
				return; 
			case InterfaceModelPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case InterfaceModelPackage.EVENT_DECLARATION:
				sequence_EventDeclaration(context, (EventDeclaration) semanticObject); 
				return; 
			case InterfaceModelPackage.EVENT_PARAMETER_REFERENCE_EXPRESSION:
				sequence_EventParameterReferenceExpression(context, (EventParameterReferenceExpression) semanticObject); 
				return; 
			case InterfaceModelPackage.EVENT_TRIGGER:
				sequence_EventTrigger(context, (EventTrigger) semanticObject); 
				return; 
			case InterfaceModelPackage.INTERFACE:
				sequence_Interface(context, (Interface) semanticObject); 
				return; 
			case InterfaceModelPackage.INTERFACE_REALIZATION:
				sequence_InterfaceRealization(context, (InterfaceRealization) semanticObject); 
				return; 
			case InterfaceModelPackage.PACKAGE:
				sequence_Package(context, (hu.bme.mit.gamma.statechart.interface_.Package) semanticObject); 
				return; 
			case InterfaceModelPackage.PORT:
				sequence_Port(context, (Port) semanticObject); 
				return; 
			case InterfaceModelPackage.TIME_SPECIFICATION:
				sequence_TimeSpecification(context, (TimeSpecification) semanticObject); 
				return; 
			case InterfaceModelPackage.WRAPPER_COMPONENT_ANNOTATION:
				sequence_WrapperComponentAnnotation(context, (WrapperComponentAnnotation) semanticObject); 
				return; 
			}
		else if (epackage == EnvironmentModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EnvironmentModelPackage.COMPONENT_FILTER:
				sequence_ComponentFilter(context, (ComponentFilter) semanticObject); 
				return; 
			case EnvironmentModelPackage.ENVIRONMENT_ASYNCHRONOUS_COMPOSITE_COMPONENT:
				sequence_EnvironmentAsynchronousCompositeComponent(context, (EnvironmentAsynchronousCompositeComponent) semanticObject); 
				return; 
			case EnvironmentModelPackage.ENVIRONMENT_ASYNCHRONOUS_COMPOSITE_COMPONENT_INSTANCE:
				sequence_EnvironmentAsynchronousCompositeComponentInstance(context, (EnvironmentAsynchronousCompositeComponentInstance) semanticObject); 
				return; 
			case EnvironmentModelPackage.ENVIRONMENT_CASCADE_COMPOSITE_COMPONENT:
				sequence_EnvironmentCascadeCompositeComponent(context, (EnvironmentCascadeCompositeComponent) semanticObject); 
				return; 
			case EnvironmentModelPackage.ENVIRONMENT_DELAY:
				sequence_EnvironmentDelay(context, (EnvironmentDelay) semanticObject); 
				return; 
			case EnvironmentModelPackage.ENVIRONMENT_EVENT_SOURCE:
				sequence_EnvironementEventSource(context, (EnvironmentEventSource) semanticObject); 
				return; 
			case EnvironmentModelPackage.ENVIRONMENT_EXTERN_SIMULATION:
				sequence_EnvironmentExternSimulation(context, (EnvironmentExternSimulation) semanticObject); 
				return; 
			case EnvironmentModelPackage.ENVIRONMENT_PERIODIC_EVENT_SOURCE:
				sequence_PeriodicEnvironementEventSource(context, (EnvironmentPeriodicEventSource) semanticObject); 
				return; 
			case EnvironmentModelPackage.ENVIRONMENT_SAMPLE:
				sequence_EnvironmentSample(context, (EnvironmentSample) semanticObject); 
				return; 
			case EnvironmentModelPackage.ENVIRONMENT_SWITCH:
				sequence_EnvironmentSwitch(context, (EnvironmentSwitch) semanticObject); 
				return; 
			case EnvironmentModelPackage.ENVIRONMENT_SYNCHRONOUS_COMPOSITE_COMPONENT:
				sequence_EnvironmentSynchronousCompositeComponent(context, (EnvironmentSynchronousCompositeComponent) semanticObject); 
				return; 
			case EnvironmentModelPackage.EVENT_FILTER:
				sequence_EventFilter(context, (EventFilter) semanticObject); 
				return; 
			case EnvironmentModelPackage.PARAMETER_FILTER:
				sequence_ParameterFilter(context, (ParameterFilter) semanticObject); 
				return; 
			case EnvironmentModelPackage.PORT_FILTER:
				sequence_PortFilter(context, (PortFilter) semanticObject); 
				return; 
			case EnvironmentModelPackage.SIMULATION:
				sequence_Simulation(context, (Simulation) semanticObject); 
				return; 
			case EnvironmentModelPackage.SIMULATION_RULE:
				if (rule == grammarAccess.getFilterSimulationRuleRule()) {
					sequence_FilterSimulationRule(context, (SimulationRule) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimulationRuleRule()) {
					sequence_SimulationRule(context, (SimulationRule) semanticObject); 
					return; 
				}
				else break;
			case EnvironmentModelPackage.STOCHASTIC_RULE:
				if (rule == grammarAccess.getDelayRuleRule()) {
					sequence_DelayRule(context, (StochasticRule) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSampleRuleRule()) {
					sequence_SampleRule(context, (StochasticRule) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStochasticRuleRule()) {
					sequence_StochasticRule(context, (StochasticRule) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSwitchRuleRule()) {
					sequence_SwitchRule(context, (StochasticRule) semanticObject); 
					return; 
				}
				else break;
			}
		else if (epackage == ExpressionModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionModelPackage.ADD_EXPRESSION:
				sequence_AdditiveExpression(context, (AddExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.ARRAY_ACCESS_EXPRESSION:
				if (rule == grammarAccess.getMixedExpressionRule()
						|| rule == grammarAccess.getAtomicExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getIfThenElseExpressionRule()
						|| action == grammarAccess.getIfThenElseExpressionAccess().getIfThenElseExpressionConditionAction_1_0()
						|| rule == grammarAccess.getImplyExpressionRule()
						|| action == grammarAccess.getImplyExpressionAccess().getImplyExpressionLeftOperandAction_1_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionOperandsAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionOperandsAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionOperandsAction_1_0()
						|| rule == grammarAccess.getUnaryLogicExpressionRule()
						|| rule == grammarAccess.getEquivalenceExpressionRule()
						|| action == grammarAccess.getEquivalenceExpressionAccess().getEqualityExpressionLeftOperandAction_1_0_0()
						|| action == grammarAccess.getEquivalenceExpressionAccess().getInequalityExpressionLeftOperandAction_1_1_0()
						|| rule == grammarAccess.getComparisionExpressionRule()
						|| action == grammarAccess.getComparisionExpressionAccess().getGreaterExpressionLeftOperandAction_1_0_0_0()
						|| action == grammarAccess.getComparisionExpressionAccess().getGreaterEqualExpressionLeftOperandAction_1_0_1_0()
						|| action == grammarAccess.getComparisionExpressionAccess().getLessExpressionLeftOperandAction_1_0_2_0()
						|| action == grammarAccess.getComparisionExpressionAccess().getLessEqualExpressionLeftOperandAction_1_0_3_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getAddExpressionOperandsAction_1_0_0()
						|| action == grammarAccess.getAdditiveExpressionAccess().getSubtractExpressionLeftOperandAction_1_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getMultiplyExpressionOperandsAction_1_0_0()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getDivideExpressionLeftOperandAction_1_1_0_0_0()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getDivExpressionLeftOperandAction_1_1_0_1_0()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getModExpressionLeftOperandAction_1_1_0_2_0()
						|| rule == grammarAccess.getSignumExpressionRule()
						|| rule == grammarAccess.getAccessExpressionRule()
						|| action == grammarAccess.getAccessExpressionAccess().getArrayAccessExpressionOperandAction_1_0_0()
						|| action == grammarAccess.getAccessExpressionAccess().getFunctionAccessExpressionOperandAction_1_1_0()
						|| action == grammarAccess.getAccessExpressionAccess().getRecordAccessExpressionOperandAction_1_2_0()
						|| action == grammarAccess.getAccessExpressionAccess().getSelectExpressionOperandAction_1_3_0()
						|| rule == grammarAccess.getExpressionLanguagePrimaryExpressionRule()) {
					sequence_AccessExpression(context, (ArrayAccessExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignableAccessExpressionRule()
						|| action == grammarAccess.getAssignableAccessExpressionAccess().getArrayAccessExpressionOperandAction_1_0_0()
						|| action == grammarAccess.getAssignableAccessExpressionAccess().getRecordAccessExpressionOperandAction_1_1_0()
						|| rule == grammarAccess.getAssignablePrimaryExpressionRule()) {
					sequence_AssignableAccessExpression(context, (ArrayAccessExpression) semanticObject); 
					return; 
				}
				else break;
			case ExpressionModelPackage.ARRAY_LITERAL_EXPRESSION:
				sequence_ArrayLiteralExpression(context, (ArrayLiteralExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.ARRAY_TYPE_DEFINITION:
				sequence_ArrayTypeDefinition(context, (ArrayTypeDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.BASIC_CONSTRAINT_DEFINITION:
				sequence_BasicConstraintDefinition(context, (BasicConstraintDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.BOOLEAN_TYPE_DEFINITION:
				sequence_BooleanTypeDefinition(context, (BooleanTypeDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.CONSTANT_DECLARATION:
				sequence_ConstantDeclaration(context, (ConstantDeclaration) semanticObject); 
				return; 
			case ExpressionModelPackage.DECIMAL_LITERAL_EXPRESSION:
				sequence_DecimalLiteralExpression(context, (DecimalLiteralExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.DECIMAL_TYPE_DEFINITION:
				sequence_DecimalTypeDefinition(context, (DecimalTypeDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.DEFAULT_EXPRESSION:
				sequence_DefaultExpression(context, (DefaultExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.DIRECT_REFERENCE_EXPRESSION:
				if (rule == grammarAccess.getAssignableAccessExpressionRule()
						|| action == grammarAccess.getAssignableAccessExpressionAccess().getArrayAccessExpressionOperandAction_1_0_0()
						|| action == grammarAccess.getAssignableAccessExpressionAccess().getRecordAccessExpressionOperandAction_1_1_0()
						|| rule == grammarAccess.getAssignablePrimaryExpressionRule()
						|| rule == grammarAccess.getAssignableDirectReferenceExpressionRule()) {
					sequence_AssignableDirectReferenceExpression(context, (DirectReferenceExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMixedExpressionRule()
						|| rule == grammarAccess.getAtomicExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getIfThenElseExpressionRule()
						|| action == grammarAccess.getIfThenElseExpressionAccess().getIfThenElseExpressionConditionAction_1_0()
						|| rule == grammarAccess.getImplyExpressionRule()
						|| action == grammarAccess.getImplyExpressionAccess().getImplyExpressionLeftOperandAction_1_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionOperandsAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionOperandsAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionOperandsAction_1_0()
						|| rule == grammarAccess.getUnaryLogicExpressionRule()
						|| rule == grammarAccess.getEquivalenceExpressionRule()
						|| action == grammarAccess.getEquivalenceExpressionAccess().getEqualityExpressionLeftOperandAction_1_0_0()
						|| action == grammarAccess.getEquivalenceExpressionAccess().getInequalityExpressionLeftOperandAction_1_1_0()
						|| rule == grammarAccess.getComparisionExpressionRule()
						|| action == grammarAccess.getComparisionExpressionAccess().getGreaterExpressionLeftOperandAction_1_0_0_0()
						|| action == grammarAccess.getComparisionExpressionAccess().getGreaterEqualExpressionLeftOperandAction_1_0_1_0()
						|| action == grammarAccess.getComparisionExpressionAccess().getLessExpressionLeftOperandAction_1_0_2_0()
						|| action == grammarAccess.getComparisionExpressionAccess().getLessEqualExpressionLeftOperandAction_1_0_3_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getAddExpressionOperandsAction_1_0_0()
						|| action == grammarAccess.getAdditiveExpressionAccess().getSubtractExpressionLeftOperandAction_1_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getMultiplyExpressionOperandsAction_1_0_0()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getDivideExpressionLeftOperandAction_1_1_0_0_0()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getDivExpressionLeftOperandAction_1_1_0_1_0()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getModExpressionLeftOperandAction_1_1_0_2_0()
						|| rule == grammarAccess.getSignumExpressionRule()
						|| rule == grammarAccess.getAccessExpressionRule()
						|| action == grammarAccess.getAccessExpressionAccess().getArrayAccessExpressionOperandAction_1_0_0()
						|| action == grammarAccess.getAccessExpressionAccess().getFunctionAccessExpressionOperandAction_1_1_0()
						|| action == grammarAccess.getAccessExpressionAccess().getRecordAccessExpressionOperandAction_1_2_0()
						|| action == grammarAccess.getAccessExpressionAccess().getSelectExpressionOperandAction_1_3_0()
						|| rule == grammarAccess.getExpressionLanguagePrimaryExpressionRule()
						|| rule == grammarAccess.getReferenceExpressionRule()
						|| rule == grammarAccess.getDirectReferenceExpressionRule()) {
					sequence_DirectReferenceExpression(context, (DirectReferenceExpression) semanticObject); 
					return; 
				}
				else break;
			case ExpressionModelPackage.DIV_EXPRESSION:
				sequence_MultiplicativeExpression(context, (DivExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.DIVIDE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (DivideExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.ELSE_EXPRESSION:
				sequence_ElseExpression(context, (ElseExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.ENUMERATION_LITERAL_DEFINITION:
				sequence_EnumerationLiteralDefinition(context, (EnumerationLiteralDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.ENUMERATION_LITERAL_EXPRESSION:
				sequence_EnumerationLiteralExpression(context, (EnumerationLiteralExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.ENUMERATION_TYPE_DEFINITION:
				sequence_EnumerationTypeDefinition(context, (EnumerationTypeDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.EQUALITY_EXPRESSION:
				sequence_EquivalenceExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.EXISTS_EXPRESSION:
				sequence_ExistsExpression(context, (ExistsExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.EXPRESSION_PACKAGE:
				sequence_ExpressionPackage(context, (ExpressionPackage) semanticObject); 
				return; 
			case ExpressionModelPackage.FALSE_EXPRESSION:
				sequence_FalseExpression(context, (FalseExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.FIELD_ASSIGNMENT:
				sequence_FieldAssignment(context, (FieldAssignment) semanticObject); 
				return; 
			case ExpressionModelPackage.FIELD_DECLARATION:
				sequence_FieldDeclaration(context, (FieldDeclaration) semanticObject); 
				return; 
			case ExpressionModelPackage.FIELD_REFERENCE_EXPRESSION:
				sequence_FieldReferenceExpression(context, (FieldReferenceExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.FORALL_EXPRESSION:
				sequence_ForallExpression(context, (ForallExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.FUNCTION_ACCESS_EXPRESSION:
				sequence_AccessExpression(context, (FunctionAccessExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.FUNCTION_TYPE_DEFINITION:
				sequence_FunctionTypeDefinition(context, (FunctionTypeDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.GREATER_EQUAL_EXPRESSION:
				sequence_ComparisionExpression(context, (GreaterEqualExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.GREATER_EXPRESSION:
				sequence_ComparisionExpression(context, (GreaterExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.IF_THEN_ELSE_EXPRESSION:
				sequence_IfThenElseExpression(context, (IfThenElseExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.IMPLY_EXPRESSION:
				sequence_ImplyExpression(context, (ImplyExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.INEQUALITY_EXPRESSION:
				sequence_EquivalenceExpression(context, (InequalityExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.INFINITY_EXPRESSION:
				sequence_InfinityExpression(context, (InfinityExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.INTEGER_LITERAL_EXPRESSION:
				sequence_IntegerLiteralExpression(context, (IntegerLiteralExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.INTEGER_RANGE_LITERAL_EXPRESSION:
				sequence_IntegerRangeLiteralExpression(context, (IntegerRangeLiteralExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.INTEGER_RANGE_TYPE_DEFINITION:
				sequence_IntegerRangeTypeDefinition(context, (IntegerRangeTypeDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.INTEGER_TYPE_DEFINITION:
				sequence_IntegerTypeDefinition(context, (IntegerTypeDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.LAMBDA_DECLARATION:
				sequence_LambdaDeclaration(context, (LambdaDeclaration) semanticObject); 
				return; 
			case ExpressionModelPackage.LESS_EQUAL_EXPRESSION:
				sequence_ComparisionExpression(context, (LessEqualExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.LESS_EXPRESSION:
				sequence_ComparisionExpression(context, (LessExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.MOD_EXPRESSION:
				sequence_MultiplicativeExpression(context, (ModExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.MULTIPLY_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplyExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.OPAQUE_EXPRESSION:
				sequence_OpaqueExpression(context, (OpaqueExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case ExpressionModelPackage.RATIONAL_LITERAL_EXPRESSION:
				sequence_RationalLiteralExpression(context, (RationalLiteralExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.RATIONAL_TYPE_DEFINITION:
				sequence_RationalTypeDefinition(context, (RationalTypeDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.RECORD_ACCESS_EXPRESSION:
				if (rule == grammarAccess.getMixedExpressionRule()
						|| rule == grammarAccess.getAtomicExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getIfThenElseExpressionRule()
						|| action == grammarAccess.getIfThenElseExpressionAccess().getIfThenElseExpressionConditionAction_1_0()
						|| rule == grammarAccess.getImplyExpressionRule()
						|| action == grammarAccess.getImplyExpressionAccess().getImplyExpressionLeftOperandAction_1_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionOperandsAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getXorExpressionOperandsAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionOperandsAction_1_0()
						|| rule == grammarAccess.getUnaryLogicExpressionRule()
						|| rule == grammarAccess.getEquivalenceExpressionRule()
						|| action == grammarAccess.getEquivalenceExpressionAccess().getEqualityExpressionLeftOperandAction_1_0_0()
						|| action == grammarAccess.getEquivalenceExpressionAccess().getInequalityExpressionLeftOperandAction_1_1_0()
						|| rule == grammarAccess.getComparisionExpressionRule()
						|| action == grammarAccess.getComparisionExpressionAccess().getGreaterExpressionLeftOperandAction_1_0_0_0()
						|| action == grammarAccess.getComparisionExpressionAccess().getGreaterEqualExpressionLeftOperandAction_1_0_1_0()
						|| action == grammarAccess.getComparisionExpressionAccess().getLessExpressionLeftOperandAction_1_0_2_0()
						|| action == grammarAccess.getComparisionExpressionAccess().getLessEqualExpressionLeftOperandAction_1_0_3_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getAddExpressionOperandsAction_1_0_0()
						|| action == grammarAccess.getAdditiveExpressionAccess().getSubtractExpressionLeftOperandAction_1_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getMultiplyExpressionOperandsAction_1_0_0()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getDivideExpressionLeftOperandAction_1_1_0_0_0()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getDivExpressionLeftOperandAction_1_1_0_1_0()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getModExpressionLeftOperandAction_1_1_0_2_0()
						|| rule == grammarAccess.getSignumExpressionRule()
						|| rule == grammarAccess.getAccessExpressionRule()
						|| action == grammarAccess.getAccessExpressionAccess().getArrayAccessExpressionOperandAction_1_0_0()
						|| action == grammarAccess.getAccessExpressionAccess().getFunctionAccessExpressionOperandAction_1_1_0()
						|| action == grammarAccess.getAccessExpressionAccess().getRecordAccessExpressionOperandAction_1_2_0()
						|| action == grammarAccess.getAccessExpressionAccess().getSelectExpressionOperandAction_1_3_0()
						|| rule == grammarAccess.getExpressionLanguagePrimaryExpressionRule()) {
					sequence_AccessExpression(context, (RecordAccessExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignableAccessExpressionRule()
						|| action == grammarAccess.getAssignableAccessExpressionAccess().getArrayAccessExpressionOperandAction_1_0_0()
						|| action == grammarAccess.getAssignableAccessExpressionAccess().getRecordAccessExpressionOperandAction_1_1_0()
						|| rule == grammarAccess.getAssignablePrimaryExpressionRule()) {
					sequence_AssignableAccessExpression(context, (RecordAccessExpression) semanticObject); 
					return; 
				}
				else break;
			case ExpressionModelPackage.RECORD_LITERAL_EXPRESSION:
				sequence_RecordLiteralExpression(context, (RecordLiteralExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.RECORD_TYPE_DEFINITION:
				sequence_RecordTypeDefinition(context, (RecordTypeDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.RESETTABLE_VARIABLE_DECLARATION_ANNOTATION:
				sequence_ResettableVariableDeclarationAnnotation(context, (ResettableVariableDeclarationAnnotation) semanticObject); 
				return; 
			case ExpressionModelPackage.SELECT_EXPRESSION:
				sequence_AccessExpression(context, (SelectExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.SUBRANGE_TYPE_DEFINITION:
				sequence_SubrangeTypeDefinition(context, (SubrangeTypeDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.SUBTRACT_EXPRESSION:
				sequence_AdditiveExpression(context, (SubtractExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.TRANSIENT_VARIABLE_DECLARATION_ANNOTATION:
				sequence_TransientVariableDeclarationAnnotation(context, (TransientVariableDeclarationAnnotation) semanticObject); 
				return; 
			case ExpressionModelPackage.TRUE_EXPRESSION:
				sequence_TrueExpression(context, (TrueExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.TYPE_DECLARATION:
				sequence_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case ExpressionModelPackage.TYPE_REFERENCE:
				sequence_TypeReference(context, (TypeReference) semanticObject); 
				return; 
			case ExpressionModelPackage.UNARY_MINUS_EXPRESSION:
				sequence_SignumExpression(context, (UnaryMinusExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.UNARY_PLUS_EXPRESSION:
				sequence_SignumExpression(context, (UnaryPlusExpression) semanticObject); 
				return; 
			case ExpressionModelPackage.UNREMOVABLE_VARIABLE_DECLARATION_ANNOTATION:
				sequence_UnremovableVariableDeclarationAnnotation(context, (UnremovableVariableDeclarationAnnotation) semanticObject); 
				return; 
			case ExpressionModelPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case ExpressionModelPackage.VOID_TYPE_DEFINITION:
				sequence_VoidTypeDefinition(context, (VoidTypeDefinition) semanticObject); 
				return; 
			case ExpressionModelPackage.XOR_EXPRESSION:
				sequence_XorExpression(context, (XorExpression) semanticObject); 
				return; 
			}
		else if (epackage == ActionModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ActionModelPackage.ASSERTION_STATEMENT:
				sequence_AssertionStatement(context, (AssertionStatement) semanticObject); 
				return; 
			case ActionModelPackage.ASSIGNMENT_STATEMENT:
				sequence_AssignmentStatement(context, (AssignmentStatement) semanticObject); 
				return; 
			case ActionModelPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case ActionModelPackage.BRANCH:
				if (rule == grammarAccess.getChoiceBranchRule()) {
					sequence_ChoiceBranch(context, (Branch) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDefaultBranchRule()) {
					sequence_DefaultBranch(context, (Branch) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getElseBranchRule()) {
					sequence_ElseBranch(context, (Branch) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfBranchRule()) {
					sequence_IfBranch(context, (Branch) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSwitchBranchRule()) {
					sequence_SwitchBranch(context, (Branch) semanticObject); 
					return; 
				}
				else break;
			case ActionModelPackage.BREAK_STATEMENT:
				sequence_BreakStatement(context, (BreakStatement) semanticObject); 
				return; 
			case ActionModelPackage.CHOICE_STATEMENT:
				sequence_ChoiceStatement(context, (ChoiceStatement) semanticObject); 
				return; 
			case ActionModelPackage.CONSTANT_DECLARATION_STATEMENT:
				sequence_ConstantDeclarationStatement(context, (ConstantDeclarationStatement) semanticObject); 
				return; 
			case ActionModelPackage.EMPTY_STATEMENT:
				sequence_EmptyStatement(context, (EmptyStatement) semanticObject); 
				return; 
			case ActionModelPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case ActionModelPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case ActionModelPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case ActionModelPackage.PROCEDURE_DECLARATION:
				sequence_ProcedureDeclaration(context, (ProcedureDeclaration) semanticObject); 
				return; 
			case ActionModelPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case ActionModelPackage.SWITCH_STATEMENT:
				sequence_SwitchStatement(context, (SwitchStatement) semanticObject); 
				return; 
			case ActionModelPackage.VARIABLE_DECLARATION_STATEMENT:
				sequence_VariableDeclarationStatement(context, (VariableDeclarationStatement) semanticObject); 
				return; 
			}
		else if (epackage == PhaseModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PhaseModelPackage.INSTANCE_VARIABLE_REFERENCE:
				sequence_InstanceVariableReference(context, (InstanceVariableReference) semanticObject); 
				return; 
			case PhaseModelPackage.MISSION_PHASE_ANNOTATION:
				sequence_MissionPhaseAnnotation(context, (MissionPhaseAnnotation) semanticObject); 
				return; 
			case PhaseModelPackage.MISSION_PHASE_STATE_ANNOTATION:
				sequence_MissionPhaseStateAnnotation(context, (MissionPhaseStateAnnotation) semanticObject); 
				return; 
			case PhaseModelPackage.VARIABLE_BINDING:
				sequence_VariableBinding(context, (VariableBinding) semanticObject); 
				return; 
			}
		else if (epackage == StatechartModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StatechartModelPackage.ANY_PORT_EVENT_REFERENCE:
				sequence_AnyPortEventReference(context, (AnyPortEventReference) semanticObject); 
				return; 
			case StatechartModelPackage.ASYNCHRONOUS_STATECHART_DEFINITION:
				sequence_AsynchronousStatechartDefinition(context, (AsynchronousStatechartDefinition) semanticObject); 
				return; 
			case StatechartModelPackage.BINARY_TRIGGER:
				sequence_AndTrigger_EqualTrigger_ImplyTrigger_OrTrigger_XorTrigger(context, (BinaryTrigger) semanticObject); 
				return; 
			case StatechartModelPackage.CHOICE_STATE:
				sequence_ChoiceState(context, (ChoiceState) semanticObject); 
				return; 
			case StatechartModelPackage.CLOCK_TICK_REFERENCE:
				sequence_ClockTickReference(context, (ClockTickReference) semanticObject); 
				return; 
			case StatechartModelPackage.DEACTIVATE_TIMEOUT_ACTION:
				sequence_DeactivateTimeoutAction(context, (DeactivateTimeoutAction) semanticObject); 
				return; 
			case StatechartModelPackage.DEEP_HISTORY_STATE:
				sequence_DeepHistoryState(context, (DeepHistoryState) semanticObject); 
				return; 
			case StatechartModelPackage.FORK_STATE:
				sequence_ForkState(context, (ForkState) semanticObject); 
				return; 
			case StatechartModelPackage.INITIAL_STATE:
				sequence_InitialState(context, (InitialState) semanticObject); 
				return; 
			case StatechartModelPackage.JOIN_STATE:
				sequence_JoinState(context, (JoinState) semanticObject); 
				return; 
			case StatechartModelPackage.MERGE_STATE:
				sequence_MergeState(context, (MergeState) semanticObject); 
				return; 
			case StatechartModelPackage.ON_CYCLE_TRIGGER:
				sequence_OnCycleTrigger(context, (OnCycleTrigger) semanticObject); 
				return; 
			case StatechartModelPackage.OPAQUE_TRIGGER:
				sequence_OpaqueTrigger(context, (OpaqueTrigger) semanticObject); 
				return; 
			case StatechartModelPackage.PORT_EVENT_REFERENCE:
				sequence_PortEventReference(context, (PortEventReference) semanticObject); 
				return; 
			case StatechartModelPackage.RAISE_EVENT_ACTION:
				sequence_RaiseEventAction(context, (RaiseEventAction) semanticObject); 
				return; 
			case StatechartModelPackage.REGION:
				sequence_Region(context, (Region) semanticObject); 
				return; 
			case StatechartModelPackage.RUN_UPON_EXTERNAL_EVENT_ANNOTATION:
				sequence_RunUponExternalEventAnnotation(context, (RunUponExternalEventAnnotation) semanticObject); 
				return; 
			case StatechartModelPackage.SET_TIMEOUT_ACTION:
				sequence_SetTimeoutAction(context, (SetTimeoutAction) semanticObject); 
				return; 
			case StatechartModelPackage.SHALLOW_HISTORY_STATE:
				sequence_ShallowHistoryState(context, (ShallowHistoryState) semanticObject); 
				return; 
			case StatechartModelPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case StatechartModelPackage.STATE_REFERENCE_EXPRESSION:
				sequence_StateReferenceExpression(context, (StateReferenceExpression) semanticObject); 
				return; 
			case StatechartModelPackage.SYNCHRONOUS_STATECHART_DEFINITION:
				sequence_SynchronousStatechartDefinition(context, (SynchronousStatechartDefinition) semanticObject); 
				return; 
			case StatechartModelPackage.TIMEOUT_DECLARATION:
				sequence_TimeoutDeclaration(context, (TimeoutDeclaration) semanticObject); 
				return; 
			case StatechartModelPackage.TIMEOUT_EVENT_REFERENCE:
				sequence_TimeoutEventReference(context, (TimeoutEventReference) semanticObject); 
				return; 
			case StatechartModelPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case StatechartModelPackage.TRANSITION_ID_ANNOTATION:
				sequence_TransitionIdAnnotation(context, (TransitionIdAnnotation) semanticObject); 
				return; 
			case StatechartModelPackage.UNARY_TRIGGER:
				sequence_NotTrigger(context, (UnaryTrigger) semanticObject); 
				return; 
			}
		else if (epackage == StochasticPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StochasticPackage.BERNOULLI_RANDOM_VARIABLE:
				sequence_BernoulliRandomVariable(context, (BernoulliRandomVariable) semanticObject); 
				return; 
			case StochasticPackage.BETA_RANDOM_VARIABLE:
				sequence_BetaRandomVariable(context, (BetaRandomVariable) semanticObject); 
				return; 
			case StochasticPackage.BROWNIAN_KERNEL:
				sequence_BrownianKernel(context, (BrownianKernel) semanticObject); 
				return; 
			case StochasticPackage.CATEGORICAL_PROBABAILITY:
				sequence_CategoricalProbabaility(context, (CategoricalProbabaility) semanticObject); 
				return; 
			case StochasticPackage.DIRAC_PROCESS:
				sequence_DiracProcess(context, (DiracProcess) semanticObject); 
				return; 
			case StochasticPackage.EXPONENTIAL_RANDOM_VARIABLE:
				sequence_ExponentialRandomVariable(context, (ExponentialRandomVariable) semanticObject); 
				return; 
			case StochasticPackage.FITTED_EXPONENTIAL_RANDOM_VARIABLE:
				sequence_FittedExponentialRandomVariable(context, (FittedExponentialRandomVariable) semanticObject); 
				return; 
			case StochasticPackage.FITTED_GAMMA_RANDOM_VARIABLE:
				sequence_FittedGammaRandomVariable(context, (FittedGammaRandomVariable) semanticObject); 
				return; 
			case StochasticPackage.FITTED_GAUSSIAN_PROCESS:
				sequence_FittedGaussianProcess(context, (FittedGaussianProcess) semanticObject); 
				return; 
			case StochasticPackage.FITTED_NORMAL_RANDOM_VARIABLE:
				sequence_FittedNormalRandomVariable(context, (FittedNormalRandomVariable) semanticObject); 
				return; 
			case StochasticPackage.GAMMA_RANDOM_VARIABLE:
				sequence_GammaRandomVariable(context, (GammaRandomVariable) semanticObject); 
				return; 
			case StochasticPackage.INFLUX_DB:
				sequence_InfluxDB(context, (InfluxDB) semanticObject); 
				return; 
			case StochasticPackage.LINEAR_KERNEL:
				sequence_LinearKernel(context, (LinearKernel) semanticObject); 
				return; 
			case StochasticPackage.LOG_NORMAL_RANDOM_VARIABLE:
				sequence_LogNormalRandomVariable(context, (LogNormalRandomVariable) semanticObject); 
				return; 
			case StochasticPackage.NORMAL_RANDOM_VARIABLE:
				sequence_NormalRandomVariable(context, (NormalRandomVariable) semanticObject); 
				return; 
			case StochasticPackage.PARETO_RANDOM_VARIABLE:
				sequence_ParetoRandomVariable(context, (ParetoRandomVariable) semanticObject); 
				return; 
			case StochasticPackage.PERIODIC_KERNEL:
				sequence_PeriodicKernel(context, (PeriodicKernel) semanticObject); 
				return; 
			case StochasticPackage.PYTHON_SIMULATION:
				sequence_PythonSimulation(context, (PythonSimulation) semanticObject); 
				return; 
			case StochasticPackage.RBF_KERNEL:
				sequence_RBFKernel(context, (RBFKernel) semanticObject); 
				return; 
			case StochasticPackage.STOCHASTIC_EXPRESSION:
				sequence_StochasticExpression(context, (StochasticExpression) semanticObject); 
				return; 
			case StochasticPackage.SUM_KERNEL:
				sequence_SumKernel(context, (SumKernel) semanticObject); 
				return; 
			case StochasticPackage.UNIFORM_RANDOM_VARIABLE:
				sequence_UniformRandomVariable(context, (UniformRandomVariable) semanticObject); 
				return; 
			case StochasticPackage.WEIBULL_RANDOM_VARIABLE:
				sequence_WeibullRandomVariable(context, (WeibullRandomVariable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns AnalysisComponent
	 *     AnalysisComponent returns AnalysisComponent
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? 
	 *         analyzedComponent=EnvironmentAsynchronousCompositeComponentInstance 
	 *         aspect+=AnalysisAspect+ 
	 *         (conditions+=AnalysisCondition | priorydistribution+=PrioryDistribution)* 
	 *         analysismethod=AnalysisMethod
	 *     )
	 * </pre>
	 */
	protected void sequence_AnalysisComponent(ISerializationContext context, AnalysisComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssumeNotRaised returns AssumeNotRaised
	 *     AnalysisCondition returns AssumeNotRaised
	 *
	 * Constraint:
	 *     event=ComponentPortEventReference
	 * </pre>
	 */
	protected void sequence_AssumeNotRaised(ISerializationContext context, AssumeNotRaised semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssumeNotRaisedAccess().getEventComponentPortEventReferenceParserRuleCall_3_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssumeRaised returns AssumeRaised
	 *     AnalysisCondition returns AssumeRaised
	 *
	 * Constraint:
	 *     event=ComponentPortEventReference
	 * </pre>
	 */
	protected void sequence_AssumeRaised(ISerializationContext context, AssumeRaised semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssumeRaisedAccess().getEventComponentPortEventReferenceParserRuleCall_2_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns BernoulliRandomVariable
	 *     RandomVariable returns BernoulliRandomVariable
	 *     DiscreteRandomVariable returns BernoulliRandomVariable
	 *     BernoulliRandomVariable returns BernoulliRandomVariable
	 *
	 * Constraint:
	 *     (probability=Expression | probability=Expression)
	 * </pre>
	 */
	protected void sequence_BernoulliRandomVariable(ISerializationContext context, BernoulliRandomVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns BetaRandomVariable
	 *     RandomVariable returns BetaRandomVariable
	 *     ContinouosRandomVariable returns BetaRandomVariable
	 *     BetaRandomVariable returns BetaRandomVariable
	 *
	 * Constraint:
	 *     ((apha=Expression beta=Expression) | (apha=Expression beta=Expression))
	 * </pre>
	 */
	protected void sequence_BetaRandomVariable(ISerializationContext context, BetaRandomVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Kernel returns BrownianKernel
	 *     BrownianKernel returns BrownianKernel
	 *
	 * Constraint:
	 *     {BrownianKernel}
	 * </pre>
	 */
	protected void sequence_BrownianKernel(ISerializationContext context, BrownianKernel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CategoricalProbabaility returns CategoricalProbabaility
	 *
	 * Constraint:
	 *     probability=Expression
	 * </pre>
	 */
	protected void sequence_CategoricalProbabaility(ISerializationContext context, CategoricalProbabaility semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.CATEGORICAL_PROBABAILITY__PROBABILITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.CATEGORICAL_PROBABAILITY__PROBABILITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCategoricalProbabailityAccess().getProbabilityExpressionParserRuleCall_0(), semanticObject.getProbability());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Filter returns ComponentFilter
	 *     ComponentFilter returns ComponentFilter
	 *
	 * Constraint:
	 *     {ComponentFilter}
	 * </pre>
	 */
	protected void sequence_ComponentFilter(ISerializationContext context, ComponentFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ComponentPortEventReference returns ComponentPortEventReference
	 *
	 * Constraint:
	 *     (component=RecursiveComponentReference port=[Port|ID] event=[Event|ID])
	 * </pre>
	 */
	protected void sequence_ComponentPortEventReference(ISerializationContext context, ComponentPortEventReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.COMPONENT_PORT_EVENT_REFERENCE__COMPONENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.COMPONENT_PORT_EVENT_REFERENCE__COMPONENT));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.COMPONENT_PORT_EVENT_REFERENCE__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.COMPONENT_PORT_EVENT_REFERENCE__PORT));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.COMPONENT_PORT_EVENT_REFERENCE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.COMPONENT_PORT_EVENT_REFERENCE__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentPortEventReferenceAccess().getComponentRecursiveComponentReferenceParserRuleCall_1_0(), semanticObject.getComponent());
		feeder.accept(grammarAccess.getComponentPortEventReferenceAccess().getPortPortIDTerminalRuleCall_3_0_1(), semanticObject.eGet(AnalysisPackage.Literals.COMPONENT_PORT_EVENT_REFERENCE__PORT, false));
		feeder.accept(grammarAccess.getComponentPortEventReferenceAccess().getEventEventIDTerminalRuleCall_5_0_1(), semanticObject.eGet(AnalysisPackage.Literals.COMPONENT_PORT_EVENT_REFERENCE__EVENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DelayRule returns StochasticRule
	 *
	 * Constraint:
	 *     ((filter+=PortFilter | filter+=ComponentFilter) (stochasticModel=ContinouosRandomVariable | stochasticModel=StochasticProcess))
	 * </pre>
	 */
	protected void sequence_DelayRule(ISerializationContext context, StochasticRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns DiracProcess
	 *     StochasticProcess returns DiracProcess
	 *     DiracProcess returns DiracProcess
	 *
	 * Constraint:
	 *     source=DataSource
	 * </pre>
	 */
	protected void sequence_DiracProcess(ISerializationContext context, DiracProcess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.DIRAC_PROCESS__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.DIRAC_PROCESS__SOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDiracProcessAccess().getSourceDataSourceParserRuleCall_3_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EndCondition returns EndCondition
	 *
	 * Constraint:
	 *     event=ComponentPortEventReference
	 * </pre>
	 */
	protected void sequence_EndCondition(ISerializationContext context, EndCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndConditionAccess().getEventComponentPortEventReferenceParserRuleCall_3_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnvironmentComponentInstance returns EnvironmentEventSource
	 *     ElementaryEnvironmentComponentInstance returns EnvironmentEventSource
	 *     EnvironementEventSource returns EnvironmentEventSource
	 *
	 * Constraint:
	 *     (name=ID outports+=Port* outports+=Port behaviorRules+=StochasticRule+)
	 * </pre>
	 */
	protected void sequence_EnvironementEventSource(ISerializationContext context, EnvironmentEventSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnvironmentAsynchronousCompositeComponentInstance returns EnvironmentAsynchronousCompositeComponentInstance
	 *     AbstractEnvironmentCompositeComponentInstance returns EnvironmentAsynchronousCompositeComponentInstance
	 *
	 * Constraint:
	 *     (name=ID type=[EnvironmentAsynchronousCompositeComponent|ID] (arguments+=MixedExpression arguments+=MixedExpression*)?)
	 * </pre>
	 */
	protected void sequence_EnvironmentAsynchronousCompositeComponentInstance(ISerializationContext context, EnvironmentAsynchronousCompositeComponentInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns EnvironmentAsynchronousCompositeComponent
	 *     EnvironmentAsynchronousCompositeComponent returns EnvironmentAsynchronousCompositeComponent
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? 
	 *         (ports+=Port ports+=Port*)? 
	 *         (components+=AsynchronousComponentInstance | environmentComponents+=EnvironmentComponentInstance | portBindings+=PortBinding | channels+=Channel)*
	 *     )
	 * </pre>
	 */
	protected void sequence_EnvironmentAsynchronousCompositeComponent(ISerializationContext context, EnvironmentAsynchronousCompositeComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns EnvironmentCascadeCompositeComponent
	 *     EnvironmentCascadeCompositeComponent returns EnvironmentCascadeCompositeComponent
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? 
	 *         (ports+=Port ports+=Port*)? 
	 *         (
	 *             (components+=SynchronousComponentInstance | environmentComponents+=EnvironmentComponentInstance | portBindings+=PortBinding | channels+=Channel)? 
	 *             (executionList+=AtomicComponentInstanceReferenceExpression executionList+=AtomicComponentInstanceReferenceExpression*)? 
	 *             (initialExecutionList+=AtomicComponentInstanceReferenceExpression initialExecutionList+=AtomicComponentInstanceReferenceExpression*)?
	 *         )+
	 *     )
	 * </pre>
	 */
	protected void sequence_EnvironmentCascadeCompositeComponent(ISerializationContext context, EnvironmentCascadeCompositeComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnvironmentComponentInstance returns EnvironmentDelay
	 *     ElementaryEnvironmentComponentInstance returns EnvironmentDelay
	 *     EnvironmentDelay returns EnvironmentDelay
	 *
	 * Constraint:
	 *     (name=ID inports+=Port outports+=Port (behaviorRules+=DelayRule | behaviorRules+=FilterSimulationRule)+)
	 * </pre>
	 */
	protected void sequence_EnvironmentDelay(ISerializationContext context, EnvironmentDelay semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnvironmentComponentInstance returns EnvironmentExternSimulation
	 *     ElementaryEnvironmentComponentInstance returns EnvironmentExternSimulation
	 *     EnvironmentExternSimulation returns EnvironmentExternSimulation
	 *
	 * Constraint:
	 *     (name=ID (inports+=Port* inports+=Port)? outports+=Port* outports+=Port behaviorRules+=SimulationRule)
	 * </pre>
	 */
	protected void sequence_EnvironmentExternSimulation(ISerializationContext context, EnvironmentExternSimulation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnvironmentComponentInstance returns EnvironmentSample
	 *     ElementaryEnvironmentComponentInstance returns EnvironmentSample
	 *     EnvironmentSample returns EnvironmentSample
	 *
	 * Constraint:
	 *     (name=ID inports+=Port outports+=Port (behaviorRules+=SampleRule | behaviorRules+=FilterSimulationRule)+)
	 * </pre>
	 */
	protected void sequence_EnvironmentSample(ISerializationContext context, EnvironmentSample semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnvironmentComponentInstance returns EnvironmentSwitch
	 *     ElementaryEnvironmentComponentInstance returns EnvironmentSwitch
	 *     EnvironmentSwitch returns EnvironmentSwitch
	 *
	 * Constraint:
	 *     (name=ID inports+=Port outports+=Port* outports+=Port behaviorRules+=SwitchRule+)
	 * </pre>
	 */
	protected void sequence_EnvironmentSwitch(ISerializationContext context, EnvironmentSwitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns EnvironmentSynchronousCompositeComponent
	 *     EnvironmentSynchronousCompositeComponent returns EnvironmentSynchronousCompositeComponent
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameterDeclarations+=ParameterDeclaration parameterDeclarations+=ParameterDeclaration*)? 
	 *         (ports+=Port ports+=Port*)? 
	 *         (components+=SynchronousComponentInstance | environmentComponents+=EnvironmentComponentInstance | portBindings+=PortBinding | channels+=Channel)*
	 *     )
	 * </pre>
	 */
	protected void sequence_EnvironmentSynchronousCompositeComponent(ISerializationContext context, EnvironmentSynchronousCompositeComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Filter returns EventFilter
	 *     EventFilter returns EventFilter
	 *
	 * Constraint:
	 *     event=PortEventReference
	 * </pre>
	 */
	protected void sequence_EventFilter(ISerializationContext context, EventFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EnvironmentModelPackage.Literals.EVENT_FILTER__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EnvironmentModelPackage.Literals.EVENT_FILTER__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventFilterAccess().getEventPortEventReferenceParserRuleCall_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnalysisAspect returns EventTimeRatio
	 *     EventTimeRatio returns EventTimeRatio
	 *
	 * Constraint:
	 *     (event=ComponentPortEventReference event2=ComponentPortEventReference)
	 * </pre>
	 */
	protected void sequence_EventTimeRatio(ISerializationContext context, EventTimeRatio semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.EVENT_TIME_RATIO__EVENT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.EVENT_TIME_RATIO__EVENT2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventTimeRatioAccess().getEventComponentPortEventReferenceParserRuleCall_3_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getEventTimeRatioAccess().getEvent2ComponentPortEventReferenceParserRuleCall_5_0(), semanticObject.getEvent2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns ExponentialRandomVariable
	 *     RandomVariable returns ExponentialRandomVariable
	 *     ContinouosRandomVariable returns ExponentialRandomVariable
	 *     ExponentialRandomVariable returns ExponentialRandomVariable
	 *
	 * Constraint:
	 *     (rate=Expression | rate=Expression)
	 * </pre>
	 */
	protected void sequence_ExponentialRandomVariable(ISerializationContext context, ExponentialRandomVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FilterSimulationRule returns SimulationRule
	 *
	 * Constraint:
	 *     (filter+=ParameterFilter* filter+=ParameterFilter simulation=Simulation)
	 * </pre>
	 */
	protected void sequence_FilterSimulationRule(ISerializationContext context, SimulationRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns FittedExponentialRandomVariable
	 *     RandomVariable returns FittedExponentialRandomVariable
	 *     ContinouosRandomVariable returns FittedExponentialRandomVariable
	 *     FittedExponentialRandomVariable returns FittedExponentialRandomVariable
	 *
	 * Constraint:
	 *     (lr=DOUBLE source=DataSource)
	 * </pre>
	 */
	protected void sequence_FittedExponentialRandomVariable(ISerializationContext context, FittedExponentialRandomVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.FITTED_MODEL__LR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.FITTED_MODEL__LR));
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.FITTED_MODEL__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.FITTED_MODEL__SOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFittedExponentialRandomVariableAccess().getLrDOUBLETerminalRuleCall_4_0(), semanticObject.getLr());
		feeder.accept(grammarAccess.getFittedExponentialRandomVariableAccess().getSourceDataSourceParserRuleCall_8_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns FittedGammaRandomVariable
	 *     RandomVariable returns FittedGammaRandomVariable
	 *     ContinouosRandomVariable returns FittedGammaRandomVariable
	 *     FittedGammaRandomVariable returns FittedGammaRandomVariable
	 *
	 * Constraint:
	 *     (lr=DOUBLE source=DataSource)
	 * </pre>
	 */
	protected void sequence_FittedGammaRandomVariable(ISerializationContext context, FittedGammaRandomVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.FITTED_MODEL__LR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.FITTED_MODEL__LR));
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.FITTED_MODEL__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.FITTED_MODEL__SOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFittedGammaRandomVariableAccess().getLrDOUBLETerminalRuleCall_4_0(), semanticObject.getLr());
		feeder.accept(grammarAccess.getFittedGammaRandomVariableAccess().getSourceDataSourceParserRuleCall_8_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns FittedGaussianProcess
	 *     StochasticProcess returns FittedGaussianProcess
	 *     FittedGaussianProcess returns FittedGaussianProcess
	 *
	 * Constraint:
	 *     (kernel=Kernel lr=DOUBLE? source=DataSource)
	 * </pre>
	 */
	protected void sequence_FittedGaussianProcess(ISerializationContext context, FittedGaussianProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns FittedNormalRandomVariable
	 *     RandomVariable returns FittedNormalRandomVariable
	 *     ContinouosRandomVariable returns FittedNormalRandomVariable
	 *     FittedNormalRandomVariable returns FittedNormalRandomVariable
	 *
	 * Constraint:
	 *     (lr=DOUBLE source=DataSource)
	 * </pre>
	 */
	protected void sequence_FittedNormalRandomVariable(ISerializationContext context, FittedNormalRandomVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.FITTED_MODEL__LR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.FITTED_MODEL__LR));
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.FITTED_MODEL__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.FITTED_MODEL__SOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFittedNormalRandomVariableAccess().getLrDOUBLETerminalRuleCall_4_0(), semanticObject.getLr());
		feeder.accept(grammarAccess.getFittedNormalRandomVariableAccess().getSourceDataSourceParserRuleCall_8_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnalysisAspect returns Frequency
	 *     Frequency returns Frequency
	 *
	 * Constraint:
	 *     event=ComponentPortEventReference
	 * </pre>
	 */
	protected void sequence_Frequency(ISerializationContext context, Frequency semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFrequencyAccess().getEventComponentPortEventReferenceParserRuleCall_2_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns GammaRandomVariable
	 *     RandomVariable returns GammaRandomVariable
	 *     ContinouosRandomVariable returns GammaRandomVariable
	 *     GammaRandomVariable returns GammaRandomVariable
	 *
	 * Constraint:
	 *     ((shape=Expression scale=Expression) | (shape=Expression scale=Expression))
	 * </pre>
	 */
	protected void sequence_GammaRandomVariable(ISerializationContext context, GammaRandomVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MCMCKernel returns HMC
	 *     HMC returns HMC
	 *
	 * Constraint:
	 *     {HMC}
	 * </pre>
	 */
	protected void sequence_HMC(ISerializationContext context, HMC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnalysisMethod returns ImportanceSampling
	 *     SimulationAnalysisMethod returns ImportanceSampling
	 *     ImportanceSampling returns ImportanceSampling
	 *
	 * Constraint:
	 *     (endcondition+=EndCondition | simulationTime=DOUBLE | simulationNumber=INTEGER | warmupTime=DOUBLE)+
	 * </pre>
	 */
	protected void sequence_ImportanceSampling(ISerializationContext context, ImportanceSampling semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataSource returns InfluxDB
	 *     InfluxDB returns InfluxDB
	 *
	 * Constraint:
	 *     (dbname=STRING ip=STRING port=STRING query=STRING)
	 * </pre>
	 */
	protected void sequence_InfluxDB(ISerializationContext context, InfluxDB semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.INFLUX_DB__DBNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.INFLUX_DB__DBNAME));
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.INFLUX_DB__IP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.INFLUX_DB__IP));
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.INFLUX_DB__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.INFLUX_DB__PORT));
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.INFLUX_DB__QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.INFLUX_DB__QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInfluxDBAccess().getDbnameSTRINGTerminalRuleCall_4_0(), semanticObject.getDbname());
		feeder.accept(grammarAccess.getInfluxDBAccess().getIpSTRINGTerminalRuleCall_8_0(), semanticObject.getIp());
		feeder.accept(grammarAccess.getInfluxDBAccess().getPortSTRINGTerminalRuleCall_12_0(), semanticObject.getPort());
		feeder.accept(grammarAccess.getInfluxDBAccess().getQuerySTRINGTerminalRuleCall_16_0(), semanticObject.getQuery());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Kernel returns LinearKernel
	 *     LinearKernel returns LinearKernel
	 *
	 * Constraint:
	 *     {LinearKernel}
	 * </pre>
	 */
	protected void sequence_LinearKernel(ISerializationContext context, LinearKernel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns LogNormalRandomVariable
	 *     RandomVariable returns LogNormalRandomVariable
	 *     ContinouosRandomVariable returns LogNormalRandomVariable
	 *     LogNormalRandomVariable returns LogNormalRandomVariable
	 *
	 * Constraint:
	 *     ((mean=Expression scale=Expression) | (mean=Expression scale=Expression))
	 * </pre>
	 */
	protected void sequence_LogNormalRandomVariable(ISerializationContext context, LogNormalRandomVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnalysisMethod returns MCMC
	 *     SimulationAnalysisMethod returns MCMC
	 *     MCMC returns MCMC
	 *
	 * Constraint:
	 *     (
	 *         endcondition+=EndCondition | 
	 *         simulationTime=DOUBLE | 
	 *         simulationNumber=INTEGER | 
	 *         warmupStepNum=INTEGER | 
	 *         kernel=MCMCKernel | 
	 *         warmupTime=DOUBLE
	 *     )+
	 * </pre>
	 */
	protected void sequence_MCMC(ISerializationContext context, MCMC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnalysisAspect returns MeanParameter
	 *     MeanParameter returns MeanParameter
	 *
	 * Constraint:
	 *     (event=ComponentPortEventReference parameter=[ParameterDeclaration|ID])
	 * </pre>
	 */
	protected void sequence_MeanParameter(ISerializationContext context, MeanParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.MEAN_PARAMETER__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.MEAN_PARAMETER__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMeanParameterAccess().getEventComponentPortEventReferenceParserRuleCall_3_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getMeanParameterAccess().getParameterParameterDeclarationIDTerminalRuleCall_5_0_1(), semanticObject.eGet(AnalysisPackage.Literals.MEAN_PARAMETER__PARAMETER, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnalysisAspect returns MeanTimeBetweenEvents
	 *     MeanTimeBetweenEvents returns MeanTimeBetweenEvents
	 *
	 * Constraint:
	 *     (event=ComponentPortEventReference event2=ComponentPortEventReference)
	 * </pre>
	 */
	protected void sequence_MeanTimeBetweenEvents(ISerializationContext context, MeanTimeBetweenEvents semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.MEAN_TIME_BETWEEN_EVENTS__EVENT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.MEAN_TIME_BETWEEN_EVENTS__EVENT2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMeanTimeBetweenEventsAccess().getEventComponentPortEventReferenceParserRuleCall_3_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getMeanTimeBetweenEventsAccess().getEvent2ComponentPortEventReferenceParserRuleCall_5_0(), semanticObject.getEvent2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnalysisAspect returns MeanTime
	 *     MeanTime returns MeanTime
	 *
	 * Constraint:
	 *     event=ComponentPortEventReference
	 * </pre>
	 */
	protected void sequence_MeanTime(ISerializationContext context, MeanTime semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMeanTimeAccess().getEventComponentPortEventReferenceParserRuleCall_3_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MCMCKernel returns NUTS
	 *     NUTS returns NUTS
	 *
	 * Constraint:
	 *     {NUTS}
	 * </pre>
	 */
	protected void sequence_NUTS(ISerializationContext context, NUTS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns NormalRandomVariable
	 *     RandomVariable returns NormalRandomVariable
	 *     ContinouosRandomVariable returns NormalRandomVariable
	 *     NormalRandomVariable returns NormalRandomVariable
	 *
	 * Constraint:
	 *     ((mean=Expression scale=Expression) | (mean=Expression scale=Expression))
	 * </pre>
	 */
	protected void sequence_NormalRandomVariable(ISerializationContext context, NormalRandomVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObserveParameter returns ObserveParameter
	 *     AnalysisCondition returns ObserveParameter
	 *
	 * Constraint:
	 *     (event=ComponentPortEventReference parameter=[ParameterDeclaration|ID] randomvariable=StochasticModel)
	 * </pre>
	 */
	protected void sequence_ObserveParameter(ISerializationContext context, ObserveParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.OBSERVE_PARAMETER__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.OBSERVE_PARAMETER__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.OBSERVE_CONDITION__RANDOMVARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.OBSERVE_CONDITION__RANDOMVARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObserveParameterAccess().getEventComponentPortEventReferenceParserRuleCall_2_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getObserveParameterAccess().getParameterParameterDeclarationIDTerminalRuleCall_4_0_1(), semanticObject.eGet(AnalysisPackage.Literals.OBSERVE_PARAMETER__PARAMETER, false));
		feeder.accept(grammarAccess.getObserveParameterAccess().getRandomvariableStochasticModelParserRuleCall_6_0(), semanticObject.getRandomvariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObserveTime returns ObserveTime
	 *     AnalysisCondition returns ObserveTime
	 *
	 * Constraint:
	 *     (event=ComponentPortEventReference randomvariable=StochasticModel)
	 * </pre>
	 */
	protected void sequence_ObserveTime(ISerializationContext context, ObserveTime semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.OBSERVE_CONDITION__RANDOMVARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.OBSERVE_CONDITION__RANDOMVARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObserveTimeAccess().getEventComponentPortEventReferenceParserRuleCall_2_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getObserveTimeAccess().getRandomvariableStochasticModelParserRuleCall_4_0(), semanticObject.getRandomvariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Package returns Package
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         imports+=[Package|STRING]* 
	 *         (
	 *             constantDeclarations+=ConstantDeclaration | 
	 *             functionDeclarations+=FunctionDeclaration | 
	 *             typeDeclarations+=TypeDeclaration | 
	 *             components+=Component | 
	 *             interfaces+=Interface
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_Package(ISerializationContext context, hu.bme.mit.gamma.statechart.interface_.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnalysisAspect returns ParameterDistribution
	 *     ParameterDistribution returns ParameterDistribution
	 *
	 * Constraint:
	 *     (event=ComponentPortEventReference parameter=[ParameterDeclaration|ID])
	 * </pre>
	 */
	protected void sequence_ParameterDistribution(ISerializationContext context, ParameterDistribution semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.PARAMETER_DISTRIBUTION__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.PARAMETER_DISTRIBUTION__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterDistributionAccess().getEventComponentPortEventReferenceParserRuleCall_3_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getParameterDistributionAccess().getParameterParameterDeclarationIDTerminalRuleCall_5_0_1(), semanticObject.eGet(AnalysisPackage.Literals.PARAMETER_DISTRIBUTION__PARAMETER, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterFilter returns ParameterFilter
	 *
	 * Constraint:
	 *     (event=PortEventReference parameter=[ParameterDeclaration|ID])
	 * </pre>
	 */
	protected void sequence_ParameterFilter(ISerializationContext context, ParameterFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EnvironmentModelPackage.Literals.EVENT_FILTER__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EnvironmentModelPackage.Literals.EVENT_FILTER__EVENT));
			if (transientValues.isValueTransient(semanticObject, EnvironmentModelPackage.Literals.PARAMETER_FILTER__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EnvironmentModelPackage.Literals.PARAMETER_FILTER__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterFilterAccess().getEventPortEventReferenceParserRuleCall_0_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getParameterFilterAccess().getParameterParameterDeclarationIDTerminalRuleCall_2_0_1(), semanticObject.eGet(EnvironmentModelPackage.Literals.PARAMETER_FILTER__PARAMETER, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns ParetoRandomVariable
	 *     RandomVariable returns ParetoRandomVariable
	 *     ContinouosRandomVariable returns ParetoRandomVariable
	 *     ParetoRandomVariable returns ParetoRandomVariable
	 *
	 * Constraint:
	 *     ((alpha=Expression scale=Expression) | (alpha=Expression scale=Expression))
	 * </pre>
	 */
	protected void sequence_ParetoRandomVariable(ISerializationContext context, ParetoRandomVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnvironmentComponentInstance returns EnvironmentPeriodicEventSource
	 *     ElementaryEnvironmentComponentInstance returns EnvironmentPeriodicEventSource
	 *     PeriodicEnvironementEventSource returns EnvironmentPeriodicEventSource
	 *
	 * Constraint:
	 *     (name=ID outports+=Port* outports+=Port (behaviorRules+=StochasticRule | behaviorRules+=FilterSimulationRule)+)
	 * </pre>
	 */
	protected void sequence_PeriodicEnvironementEventSource(ISerializationContext context, EnvironmentPeriodicEventSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Kernel returns PeriodicKernel
	 *     PeriodicKernel returns PeriodicKernel
	 *
	 * Constraint:
	 *     {PeriodicKernel}
	 * </pre>
	 */
	protected void sequence_PeriodicKernel(ISerializationContext context, PeriodicKernel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Filter returns PortFilter
	 *     PortFilter returns PortFilter
	 *
	 * Constraint:
	 *     port=[Port|ID]
	 * </pre>
	 */
	protected void sequence_PortFilter(ISerializationContext context, PortFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EnvironmentModelPackage.Literals.PORT_FILTER__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EnvironmentModelPackage.Literals.PORT_FILTER__PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortFilterAccess().getPortPortIDTerminalRuleCall_0_0_1(), semanticObject.eGet(EnvironmentModelPackage.Literals.PORT_FILTER__PORT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrioryDistribution returns PrioryDistribution
	 *
	 * Constraint:
	 *     (parameter=[ParameterDeclaration|ID] randomvariable=RandomVariable)
	 * </pre>
	 */
	protected void sequence_PrioryDistribution(ISerializationContext context, PrioryDistribution semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.PRIORY_DISTRIBUTION__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.PRIORY_DISTRIBUTION__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.PRIORY_DISTRIBUTION__RANDOMVARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.PRIORY_DISTRIBUTION__RANDOMVARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrioryDistributionAccess().getParameterParameterDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(AnalysisPackage.Literals.PRIORY_DISTRIBUTION__PARAMETER, false));
		feeder.accept(grammarAccess.getPrioryDistributionAccess().getRandomvariableRandomVariableParserRuleCall_3_0(), semanticObject.getRandomvariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnalysisAspect returns Probability
	 *     Probability returns Probability
	 *
	 * Constraint:
	 *     event=ComponentPortEventReference
	 * </pre>
	 */
	protected void sequence_Probability(ISerializationContext context, Probability semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProbabilityAccess().getEventComponentPortEventReferenceParserRuleCall_2_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataSource returns PythonSimulation
	 *     PythonSimulation returns PythonSimulation
	 *
	 * Constraint:
	 *     script=STRING
	 * </pre>
	 */
	protected void sequence_PythonSimulation(ISerializationContext context, PythonSimulation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.PYTHON_SIMULATION__SCRIPT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.PYTHON_SIMULATION__SCRIPT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPythonSimulationAccess().getScriptSTRINGTerminalRuleCall_2_0(), semanticObject.getScript());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Kernel returns RBFKernel
	 *     RBFKernel returns RBFKernel
	 *
	 * Constraint:
	 *     {RBFKernel}
	 * </pre>
	 */
	protected void sequence_RBFKernel(ISerializationContext context, RBFKernel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RecursiveComponentReference returns RecursiveComponentReference
	 *
	 * Constraint:
	 *     component=[EnvironmentAsynchronousCompositeComponentInstance|ID]
	 * </pre>
	 */
	protected void sequence_RecursiveComponentReference(ISerializationContext context, RecursiveComponentReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.RECURSIVE_COMPONENT_REFERENCE__COMPONENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.RECURSIVE_COMPONENT_REFERENCE__COMPONENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecursiveComponentReferenceAccess().getComponentEnvironmentAsynchronousCompositeComponentInstanceIDTerminalRuleCall_0_1(), semanticObject.eGet(AnalysisPackage.Literals.RECURSIVE_COMPONENT_REFERENCE__COMPONENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SampleRule returns StochasticRule
	 *
	 * Constraint:
	 *     (filter+=ParameterFilter* filter+=ParameterFilter (stochasticModel=RandomVariable | stochasticModel=StochasticProcess))
	 * </pre>
	 */
	protected void sequence_SampleRule(ISerializationContext context, StochasticRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimulationRule returns SimulationRule
	 *
	 * Constraint:
	 *     simulation=Simulation
	 * </pre>
	 */
	protected void sequence_SimulationRule(ISerializationContext context, SimulationRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EnvironmentModelPackage.Literals.SIMULATION_RULE__SIMULATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EnvironmentModelPackage.Literals.SIMULATION_RULE__SIMULATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimulationRuleAccess().getSimulationSimulationParserRuleCall_0(), semanticObject.getSimulation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Simulation returns Simulation
	 *
	 * Constraint:
	 *     simulationClassName=STRING
	 * </pre>
	 */
	protected void sequence_Simulation(ISerializationContext context, Simulation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EnvironmentModelPackage.Literals.SIMULATION__SIMULATION_CLASS_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EnvironmentModelPackage.Literals.SIMULATION__SIMULATION_CLASS_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimulationAccess().getSimulationClassNameSTRINGTerminalRuleCall_2_0(), semanticObject.getSimulationClassName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MixedExpression returns StochasticExpression
	 *     StochasticExpression returns StochasticExpression
	 *
	 * Constraint:
	 *     randomvariable=RandomVariable
	 * </pre>
	 */
	protected void sequence_StochasticExpression(ISerializationContext context, StochasticExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StochasticPackage.Literals.STOCHASTIC_EXPRESSION__RANDOMVARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StochasticPackage.Literals.STOCHASTIC_EXPRESSION__RANDOMVARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStochasticExpressionAccess().getRandomvariableRandomVariableParserRuleCall_2_0(), semanticObject.getRandomvariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticRule returns StochasticRule
	 *
	 * Constraint:
	 *     (filter+=Filter* filter+=Filter stochasticModel=StochasticModel)
	 * </pre>
	 */
	protected void sequence_StochasticRule(ISerializationContext context, StochasticRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Kernel returns SumKernel
	 *     SumKernel returns SumKernel
	 *
	 * Constraint:
	 *     (kernels+=Kernel kernels+=Kernel)
	 * </pre>
	 */
	protected void sequence_SumKernel(ISerializationContext context, SumKernel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SwitchRule returns StochasticRule
	 *
	 * Constraint:
	 *     (filter+=PortFilter stochasticModel=CategoricalProbabaility)
	 * </pre>
	 */
	protected void sequence_SwitchRule(ISerializationContext context, StochasticRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimeBoundedProbability returns TimeBoundedProbability
	 *
	 * Constraint:
	 *     (event=ComponentPortEventReference lowerBound=DOUBLE upperBound=DOUBLE)
	 * </pre>
	 */
	protected void sequence_TimeBoundedProbability(ISerializationContext context, TimeBoundedProbability semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.TIME_BOUNDED_PROBABILITY__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.TIME_BOUNDED_PROBABILITY__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.TIME_BOUNDED_PROBABILITY__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.TIME_BOUNDED_PROBABILITY__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeBoundedProbabilityAccess().getEventComponentPortEventReferenceParserRuleCall_2_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getTimeBoundedProbabilityAccess().getLowerBoundDOUBLETerminalRuleCall_4_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getTimeBoundedProbabilityAccess().getUpperBoundDOUBLETerminalRuleCall_6_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimedProbability returns TimedProbability
	 *
	 * Constraint:
	 *     (event=ComponentPortEventReference timeLimit=DOUBLE)
	 * </pre>
	 */
	protected void sequence_TimedProbability(ISerializationContext context, TimedProbability semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.ANALYSIS_ASPECT__EVENT));
			if (transientValues.isValueTransient(semanticObject, AnalysisPackage.Literals.TIMED_PROBABILITY__TIME_LIMIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnalysisPackage.Literals.TIMED_PROBABILITY__TIME_LIMIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimedProbabilityAccess().getEventComponentPortEventReferenceParserRuleCall_2_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getTimedProbabilityAccess().getTimeLimitDOUBLETerminalRuleCall_4_0(), semanticObject.getTimeLimit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns UniformRandomVariable
	 *     RandomVariable returns UniformRandomVariable
	 *     ContinouosRandomVariable returns UniformRandomVariable
	 *     UniformRandomVariable returns UniformRandomVariable
	 *
	 * Constraint:
	 *     ((lowerBound=Expression upperBound=Expression) | (lowerBound=Expression upperBound=Expression))
	 * </pre>
	 */
	protected void sequence_UniformRandomVariable(ISerializationContext context, UniformRandomVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StochasticModel returns WeibullRandomVariable
	 *     RandomVariable returns WeibullRandomVariable
	 *     ContinouosRandomVariable returns WeibullRandomVariable
	 *     WeibullRandomVariable returns WeibullRandomVariable
	 *
	 * Constraint:
	 *     ((shape=Expression scale=Expression) | (shape=Expression scale=Expression))
	 * </pre>
	 */
	protected void sequence_WeibullRandomVariable(ISerializationContext context, WeibullRandomVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
