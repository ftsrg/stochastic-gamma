/********************************************************************************
 * Copyright (c) 2018-2024 Contributors to the Gamma project
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ********************************************************************************/
package hu.bme.mit.gamma.environment.analysis.transformation.pythongen

import hu.bme.mit.gamma.environment.analysis.AnalysisComponent
import hu.bme.mit.gamma.environment.model.EnvironmentAsynchronousCompositeComponentInstance
import hu.bme.mit.gamma.environment.model.EnvironmentSynchronousCompositeComponentInstance
import hu.bme.mit.gamma.expression.util.ExpressionEvaluator
import hu.bme.mit.gamma.statechart.composite.ComponentInstance
import org.eclipse.core.resources.ResourcesPlugin
import java.io.File
import hu.bme.mit.gamma.environment.analysis.transformation.util.TransformationUtility
import hu.bme.mit.gamma.environment.analysis.transformation.util.ElementaryComponentCollector
import hu.bme.mit.gamma.environment.analysis.SimulationAnalysisMethod

import static extension hu.bme.mit.gamma.codegeneration.java.util.TimingDeterminer.*

import static extension hu.bme.mit.gamma.environment.analysis.transformation.util.TransformationUtility.*
import static extension hu.bme.mit.gamma.environment.model.utils.EnvironmentModelDerivedFeatures.*
import static extension hu.bme.mit.gamma.environment.analysis.transformation.pythongen.PyroAnalysisGenerator.*
import hu.bme.mit.gamma.codegeneration.java.util.TimingDeterminer
import java.time.LocalDateTime

class PyroSimulatorGenerator {
		
	
	def generate(AnalysisComponent analysis_component,String packageName,String basePackage) {
		var component=(analysis_component.analyzedComponent instanceof EnvironmentAsynchronousCompositeComponentInstance) ? 
			(analysis_component.analyzedComponent as EnvironmentAsynchronousCompositeComponentInstance).type :
			(analysis_component.analyzedComponent as EnvironmentSynchronousCompositeComponentInstance).type
		var stack=<ComponentInstance>newArrayList()
		var connections=ElementaryComponentCollector.collect(analysis_component.analyzedComponent,stack)
		var distGenerator=new PyroDistGenerator
		var compClassGenerator=new PyroComponentClassGenerator(packageName,analysis_component)
		var expEval=ExpressionEvaluator.INSTANCE 
		var workspace = ResourcesPlugin.getWorkspace()
		var projectName = ResourcesPlugin.workspace.root.getProjects()
		var workspaceDirectory = workspace.root.rawLocationURI.toString.replaceAll("^file:/","").replace('/',File.separatorChar)
		val strSep="\\"+File.separator
		//var jarSources = (workspaceDirectory+File.separator+packageName+File.separator+"bin").replaceAll("\\\\","\\\\\\\\")
		var jarSources = (basePackage+File.separator+"bin").replaceAll("\\\\","\\\\\\\\").replaceAll("/","\\\\\\\\")
		var jvmHome=(System.getProperty("java.home")+File.separator+"bin"+File.separator+"server"+File.separator+"jvm.dll").replaceAll("\\\\","\\\\\\\\")
		var analysisGen=new PyroAnalysisGenerator	
		var analysismethod = analysis_component.analysismethod as SimulationAnalysisMethod
		val debug=analysismethod.debug
		val jointSampling=analysismethod.jointSampling	
'''
# automatically generated probabilistic program
# generated by Gamma Composition Framework
# time of model generation: «LocalDateTime.now.toString»

«generateImports»


# manually build the java code
BUILD=False
«IF debug»
	# manually build the java code
	INIT_GEN=False
«ENDIF»
# synchronization of elementary stochastic components in synchronous composition
IESC_SYNC=False

# conversion between the time unit of elementary stochastic components and millisecond
time_conv=1.0 # 1000000000.0*60*60*1000

simTime=«Double.toString(expEval.evaluateDecimal(analysismethod.simulationTime))»
simNumber=«expEval.evaluateInteger(analysismethod.simulationNumber)»

«analysisGen.generateMarginalVisualisation()»
«IF debug»
	«generateDiagPrint»
«ENDIF»

print('initiating Python-Java connection')

def create_detmodel():
	if BUILD:
		commands = ["""javac $(find «workspaceDirectory.replaceAll("\\\\","\\\\\\\\")» -name "*.java")"""]
		for command in commands:
			if os.system(command) == 0:
				continue
			else:
				print( "ERROR")
				break
	startJVM("""«jvmHome»""", '-ea',"""-Djava.class.path=«jarSources»""")
	detmodel = 0
	EntryPoint = JClass('javaenv.«analysis_component.name.toFirstUpper»EntryPoint')
	detmodel = EntryPoint()
	print('Python-Java connection established')
	return detmodel

detmodel=create_detmodel()



# python classes of random variables and distributions
«distGenerator.generateClasses(analysismethod)»

«compClassGenerator.generateClasses(connections)»

«PyroStochasticClassGenerator.generate(analysis_component,packageName)»


print("creating stochastic event generator")
stochmodel=0
try:
	stochmodel = StochasticEventGenerator(detmodel)
	print("stochastic event generator is successfully created")
except jpype.JException as ex:
		print("Caught base exception : ", str(ex))
		print(ex.stacktrace())
		shutdownJVM()
except Exception as ex:
		print("Caught python exception :", str(ex))
		traceback.print_exc()
		shutdownJVM()

def state2num(state):
	if state=="run":
		return 0.0
	else:
		return 1.0

«analysis_component.generateSimulator»

«analysisGen.generateMain(analysis_component)»



'''
		}
		
	def generateImports(){
		'''
			import pyro
			import torch
			import pyro.distributions as dist
			import pyro.contrib.gp as gp
			from pyro.distributions.torch_distribution import TorchDistribution
			from pyro.distributions.util import broadcast_shape
			import numpy as np
			
			import math
			from math import exp
			import statistics as stats
			
			import matplotlib.pyplot as plt
			import matplotlib
			
			# import datetime
			# from influxdb import InfluxDBClient
			
			
			import time
			import os
			import traceback
			from jpype import JImplements, JOverride
			from jpype import *
			import jpype
			import hashlib
			
		'''
	}
	
	def generateSimulator(AnalysisComponent analysis_component){
		var analysismethod = analysis_component.analysismethod as SimulationAnalysisMethod
		val debug=analysismethod.debug
		val jointSampling=analysismethod.jointSampling	
		'''
		def simulate():
				
			# global objects: stochastic event generator and deterministic evaluator
			global stochmodel, detmodel
			
			«generateDebugAspectVars(analysis_component.aspect)»
			
			«IF debug»
				print("New simulation run --------------------------------------------------")
				dinit()
			«ENDIF»
			
			# initialize the stochastic event generator
			stochmodel.reset()
			stochmodel.generateEvents()
			
			# schedule the asynchronous component
			detmodel.get«analysis_component.analyzedComponent.name.toFirstUpper»().schedule()
			
			«IF debug»
				if INIT_GEN:
					print("Initial events: ---------------------------------------------")
					dprint('note over stochmodel ')
					dprint('| Source of the event | Name of the event | Time of the event |')
					for event in stochmodel.events:
						print("      ESC name: ", event.eventSource.name + "   Event name: " + event.name +'   Time: ' + str(event.eventTime))
						dprint("|   ", event.eventSource.name + "   | " + event.name +'   | ' + str(event.eventTime)+ ' |')
					print("Simulation events: ---------------------------------------------")
					dprint('endnote')
					#dprint("== Simulation Starts ==")
			«ENDIF»
			
			# run the simulator until there are stochastic events available and simulation time is not reached
			while len(stochmodel.events) > 0 and stochmodel.time <= simTime:
				

				
				«IF TimingDeterminer.INSTANCE.needTimer(analysis_component.analyzedComponent.type)»
					gamma_time=detmodel.timer.getEarliestTime()
					stoch_time=(stochmodel.getEarliestTime())*time_conv
					# if Deterministic Evaluator code has the earliest alarm clock
					if (float(gamma_time) < stoch_time) and (float(gamma_time)<=(simTime-stochmodel.time)*time_conv):
						«IF debug»
							print("Gamma timed event simulation++++++++++++")
							dprint(f'detmodel -> detmodel : "Gamma timeout, {gamma_time} ms at {str(stochmodel.time)}"')
						«ENDIF»
						detmodel.timer.elapse(gamma_time)
						stochmodel.time = stochmodel.time + float(gamma_time)/time_conv
						detmodel.get«analysis_component.analyzedComponent.name.toFirstUpper»().schedule()
					# if Stochastic Event Generator has the earliest alarm clock
					else:
						# get the event with the earliest clock
						event = stochmodel.popEvent()
						deltaTime = event.eventTime - stochmodel.time
						
						if event.eventTime > simTime :
							«IF debug»
								print("End condition is satisfied: ---------------------------------------------")
								print("       Out of time")
								dprint("== Simulation Ends: Time limit is reached ==")
							«ENDIF»
							break
						
						# insert the event into the deterministic evaluator
						stochmodel.time = event.eventTime
						
						«IF debug»
							# print debug event information
							print("      ESC name: ", event.eventSource.name + "   Event name: " + event.name + '   Time: ' + str(event.eventTime))
							dprint(f'stochmodel -> detmodel : {event.eventSource.name}  ::  {event.name} at {str(event.eventTime)}')
						«ENDIF»
						# raise the event
						event.eventCall()
						
						# schedule the deterministic evaluator
						detmodel.get«analysis_component.analyzedComponent.name.toFirstUpper»().schedule()
						detmodel.timer.elapse(int(deltaTime))
				«ELSE»
					# get the event with the earliest clock
					stochmodel.getEarliestTime()
					event = stochmodel.popEvent()

					
					if event.eventTime > simTime :
						«IF debug»
							print("End condition is satisfied: ---------------------------------------------")
							print("       Out of time")
							dprint("== Simulation Ends: Time limit is reached ==")
						«ENDIF»
						break
					
					# insert the event into the deterministic evaluator
					stochmodel.time = event.eventTime
					
					«IF debug»
						# print debug event information
						print("      ESC name: ", event.eventSource.name + "   Event name: " + event.name + '   Time: ' + str(event.eventTime))
						dprint(f'stochmodel -> detmodel : "{event.eventSource.name}  ::  {event.name} at {str(event.eventTime)}"')
					«ENDIF»
					# raise the event
					event.eventCall()
					
					# schedule the deterministic evaluator
					detmodel.get«analysis_component.analyzedComponent.name.toFirstUpper»().schedule()
				«ENDIF»
				

				# evaluate end condition
				«IF debug»
					«generateDebugAspectRegistry(analysis_component.aspect)»
				«ENDIF»
				
				«FOR endCondition : analysismethod.endcondition»
					if detmodel.monitorOf«generateEndConditionName(endCondition)».state != "run":
						# print debug end condition information
						«IF debug»
							print("End condition is satisfied: ---------------------------------------------")
							print("      «generateEndConditionName(endCondition)» : ", detmodel.monitorOf«generateEndConditionName(endCondition)».state)
							dprint('hnote over analysis ')
							dprint('«generateEndConditionName(endCondition)» is reached')
							dprint("endnote")
						«ENDIF»
						break
				«ENDFOR»
			«generatePyroAspectRegistry(analysis_component.aspect)»
			«generatePyroConditionRegistry(analysis_component.conditions)»
			
			«IF debug»
				print("Simulation is finished! ---------------------------------------------")
				dsave()
				if len(stochmodel.events) == 0:
					dprint('hnote over stochmodel ')
					dprint('no stochastic event')
					dprint("endnote")				
			«ENDIF»
			
			# get the aspects and return from the simulations 
			«generateSimulationReturn(analysis_component.aspect)»
		'''
	}
	
	def generateDiagPrint(){
		return 
		'''
		debug_diag_cntr=0
		debug_diag=""
		diag_hashes=set()
		def dprint(*args, **kwargs):
			global debug_diag
			for a in args:
				debug_diag=debug_diag+str(a)
			debug_diag=debug_diag+"\n"
		
		def dinit():
			global debug_diag
			debug_diag="""
			@startuml
			participant "Stochastic Models" as stochmodel
			participant "Deteministic Models" as detmodel
			participant "Analysis Case" as analysis
			"""
		
		def dsave():
			global debug_diag, debug_diag_cntr
			debug_diag=debug_diag+("@enduml")
			#hash_str=hashlib.md5(debug_diag.encode()).hexdigest()
			#if hash_str not in diag_hashes:
			isExist = os.path.exists("debug_diag")
			if not isExist:
				os.makedirs("debug_diag")
			with open(f'debug_diag/diag{debug_diag_cntr}.plantuml', 'w') as f:
				f.write(debug_diag)
			debug_diag_cntr=debug_diag_cntr+1
			print(debug_diag)
			debug_diag=""
		'''
	}
		
}