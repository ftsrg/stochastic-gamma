grammar hu.mit.gamma.environment.language.EnvironmentLanguage 
	with hu.bme.mit.gamma.statechart.language.StatechartLanguage

//import "http://www.mit.bme.hu/gamma/environment/Model" as Env
import "platform:/resource/hu.bme.mit.gamma.stochastic.model/model/stochastic.ecore" as StochasticModel
import "platform:/resource/hu.bme.mit.gamma.environment.model/model/environment.ecore" as EnvironmentModel 
import "platform:/resource/hu.bme.mit.gamma.analysis.model/model/analysis.ecore" as AnalysisModel
import "platform:/resource/hu.bme.mit.gamma.expression.model/model/expression.ecore"
import "http://www.eclipse.org/emf/2002/Ecore" as Ecore
import "http://www.mit.bme.hu/gamma/statechart/Model/Statechart" as StatechartModel
//import "http://www.mit.bme.hu/gamma/expression/Model" as ConstraintModel 
import "http://www.mit.bme.hu/gamma/action/Model" as ActionModel 
import "http://www.mit.bme.hu/gamma/statechart/Model/Composite" as CompositeModel
import "http://www.mit.bme.hu/gamma/statechart/Model/Interface" as InterfaceModel 
 
//generate EnvironmentLanguage "http://www.mit.bme.hu/gamma/environment/language/dwdEnvironmentLanguage"



@Override 
Package returns InterfaceModel::Package: 'package' name=ID
	('import' imports+=[InterfaceModel::Package | STRING])*	
	(
		constantDeclarations+=ConstantDeclaration |
		functionDeclarations+=FunctionDeclaration |
		typeDeclarations+=TypeDeclaration |
		components+=Component |
		interfaces+=Interface
	)*
;



@Override 
Component returns InterfaceModel::Component:
	SynchronousComponent |
	EnvironmentCompositeComponent |
	AnalysisComponent |
	RequirementComponent
;


//defining Analysis and Requirement models

RequirementComponent returns AnalysisModel::RequirementComponent: 
	'requirement' name=ID
	('(' ((parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)*)? ')')?
	'{'
		'in' analyzedComponent=EnvironmentCompositeComponentInstance
		aspect=AnalysisAspect 
		requirement+=RequirementAspect
		(conditions+=AnalysisCondition)*
	'}'
;



RequirementAspect returns AnalysisModel::RequirementAspect: 
	LowerThan | GreaterThan | IsBetween
;


LowerThan returns AnalysisModel::LowerThan: 
	'lower than' value=DOUBLE
	('description' description=STRING)?
;

GreaterThan returns AnalysisModel::GreaterThan: 
	'greater than' value=DOUBLE
	('description' description=STRING)?
;

IsBetween returns AnalysisModel::IsBetween: 
	'in' '[' lowerBound=DOUBLE ',' upperBound=DOUBLE ']'
	('description' description=STRING)?
;


AnalysisComponent returns AnalysisModel::AnalysisComponent: 
	'analysis' name=ID
	('(' ((parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)*)? ')')?
	'{'
		'in' analyzedComponent=EnvironmentCompositeComponentInstance
		aspect=AnalysisAspect
		("simulation" "time" "=" simulationTime=DOUBLE)?
		("simulation" "number" "=" simulationNumber=INTEGER)?
		(conditions+=AnalysisCondition)*
	'}'
;



AnalysisAspect returns AnalysisModel::AnalysisAspect: 
	Probability | TimedProbability | TimeBoundedProbability | MeanTime | Frequency
;

MeanParameter returns AnalysisModel::MeanParameter: 
	'mean' 'parameter' 'of' event=ComponentPortEventReference  
;

ParameterDistribution returns AnalysisModel::ParameterDistribution: 
	'parameter' 'distribution' 'of' event=ComponentPortEventReference 
;

Probability returns AnalysisModel::Probability: 
	'probability' 'of' event=ComponentPortEventReference  
;

TimedProbability returns AnalysisModel::TimedProbability: 
	'probability' 'of' event=ComponentPortEventReference  'until' timeLimit=DOUBLE 
;

TimeBoundedProbability returns AnalysisModel::TimeBoundedProbability: 
	'probability' 'of' event=ComponentPortEventReference  'from' lowerBound=DOUBLE 'to'upperBound=DOUBLE
;

MeanTime returns AnalysisModel::MeanTime: 
	'mean' 'time' 'of' event=ComponentPortEventReference
;

Frequency returns AnalysisModel::Frequency:
	'frequency' 'of' event=ComponentPortEventReference
;

AssumeRaised returns AnalysisModel::AssumeRaised: 
	'assume' event=ComponentPortEventReference  'raised'
;

AssumeNotRaised returns AnalysisModel::AssumeNotRaised: 
	'assume' event=ComponentPortEventReference  'not' 'raised'
;

AnalysisCondition returns AnalysisModel::AnalysisCondition: 
	AssumeRaised | AssumeNotRaised
;


ComponentPortEventReference returns AnalysisModel::ComponentPortEventReference: 
	'event' '[' component=[EnvironmentModel::EnvironmentCompositeComponentInstance]'.'port=[InterfaceModel::Port]'.'event=[InterfaceModel::Event] ']'
;


//defining Environment models

EnvironmentCompositeComponent returns EnvironmentModel::EnvironmentCompositeComponent: 
	'environment' name=ID 
	('(' ((parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)*)? ')')?
		('[' ((ports+=Port)((',')? ports+=Port)*)? ']')?
		'{'
			(
				components+=SynchronousComponentInstance |
				environmentComponents+=EnvironmentComponentInstance |
				portBindings+=PortBinding |
				channels+=Channel |
				'failure' 'propagation' executionList+=[CompositeModel::SynchronousComponentInstance] (',' executionList+=[CompositeModel::SynchronousComponentInstance])*
			)*
		'}'
;	

/* 
@Override
Package returns StatechartModel::Package:
	super
;*/
 

// Composition language 
 

EnvironmentComponentInstance returns EnvironmentModel::EnvironmentComponentInstance: 
	ElementaryEnvironmentComponentInstance | EnvironmentCompositeComponentInstance
;


ElementaryEnvironmentComponentInstance returns EnvironmentModel::ElementaryEnvironmentComponentInstance: 
	EnvironementEventSource | PeriodicEnvironementEventSource | EnvironmentDelay | EnvironmentSample | EnvironmentSwitch | EnvironmentExternSimulation
;


EnvironmentCompositeComponentInstance returns EnvironmentModel::EnvironmentCompositeComponentInstance: 
	'environment' 'component' name=ID ':' type=[EnvironmentModel::EnvironmentCompositeComponent] ('(' arguments+=Expression (',' arguments+=Expression)* ')')?
;


StochasticRule returns EnvironmentModel::StochasticRule: 
	(filter+=Filter ",")* filter+=Filter ":" stochasticModel=StochasticModel
;


FilterSimulationRule returns EnvironmentModel::SimulationRule: 
	(filter+=Filter ",")* filter+=Filter ":" simulation=Simulation
;


SwitchRule returns EnvironmentModel::StochasticRule:
	filter+=PortFilter ':' stochasticModel=CategoricalProbabaility
;

DelayRule returns EnvironmentModel::StochasticRule:
	(filter+=PortFilter | filter+=ComponentFilter) ':' (stochasticModel=ContinouosRandomVariable | stochasticModel=StochasticProcess )
;

Filter returns EnvironmentModel::Filter: 
	EventFilter | PortFilter | ComponentFilter
;



EventFilter returns EnvironmentModel::EventFilter: 
	event=PortEventReference
;

PortFilter returns EnvironmentModel::PortFilter: 
	port=[InterfaceModel::Port]"." "*"
;

ComponentFilter returns EnvironmentModel::ComponentFilter: 
	{EnvironmentModel::ComponentFilter} "*" "." "*"
;

SimulationRule returns EnvironmentModel::SimulationRule: 
	simulation=Simulation
;

Simulation returns EnvironmentModel::Simulation: 
	"class" "=" simulationClassName=STRING
;


EnvironementEventSource returns EnvironmentModel::EnvironmentEventSource: 
	'source' name=ID  (outports+=Port ",")* outports+=Port "{" 
		(behaviorRules+=StochasticRule ";")+	
	"}" 
;


PeriodicEnvironementEventSource returns EnvironmentModel::EnvironmentPeriodicEventSource: 
	'periodic' 'source' name=ID  (outports+=Port ",")* outports+=Port "{" 
		(behaviorRules+=(StochasticRule | FilterSimulationRule)";")+	
	"}" 
;

EnvironmentSwitch returns EnvironmentModel::EnvironmentSwitch: 
	'switch' name=ID inports+=Port "->"  (outports+=Port ",")*outports+=Port "{" 
		(behaviorRules+=SwitchRule ";")+	
	"}" 
;

EnvironmentDelay returns EnvironmentModel::EnvironmentDelay: 
	'delay' name=ID inports+=Port "->"  outports+=Port "{" 
		(behaviorRules+=(DelayRule| FilterSimulationRule)";")+	
	"}" 
;

EnvironmentSample returns EnvironmentModel::EnvironmentSample: 
	'sample' name=ID inports+=Port "->"  outports+=Port "{" 
		(behaviorRules+=(StochasticRule| FilterSimulationRule)";")+	
	"}" 
;

EnvironmentExternSimulation returns EnvironmentModel::EnvironmentExternSimulation: 
	'simulation' name=ID (((inports+=Port ",")*inports+=Port "<->") | ("|->"))(outports+=Port ",")*outports+=Port "with" behaviorRules+=SimulationRule
;




StochasticModel returns StochasticModel::StochasticModel: 
	StochasticProcess | RandomVariable
;


StochasticProcess returns StochasticModel::StochasticProcess: 
	FittedGaussianProcess | DiracProcess
;


RandomVariable returns StochasticModel::RandomVariable: 
	ContinouosRandomVariable | DiscreteRandomVariable
;


ContinouosRandomVariable returns StochasticModel::ContinouosRandomVariable: 
	NormalRandomVariable | 
	ExponentialRandomVariable | 
	WeibullRandomVariable | 
	GammaRandomVariable | 
	FittedExponentialRandomVariable | 
	FittedGammaRandomVariable |
	FittedNormalRandomVariable
;

DiscreteRandomVariable returns StochasticModel::DiscreteRandomVariable: 
	BernoulliRandomVariable
;


NormalRandomVariable returns StochasticModel::NormalRandomVariable: 
	'normal' 'mean' '=' mean=DOUBLE ',' 'scale' '=' scale=DOUBLE 
;

WeibullRandomVariable returns StochasticModel::WeibullRandomVariable: 
	('Weibull' | 'weibull') 'scale' '=' scale=DOUBLE ',' 'shape' '=' shape=DOUBLE
;

GammaRandomVariable returns StochasticModel::GammaRandomVariable: 
	'gamma' 'scale' '=' scale=DOUBLE ',' 'shape' '=' shape=DOUBLE
;


ExponentialRandomVariable returns StochasticModel::ExponentialRandomVariable: 
	'exponential' 'rate=' rate=DOUBLE 
;

BernoulliRandomVariable returns StochasticModel::BernoulliRandomVariable: 
	'bernoulli' 'prob=' probability=DOUBLE 
;


FittedExponentialRandomVariable returns StochasticModel::FittedExponentialRandomVariable: 
	'fitted' 'exponential' 'lr' '=' lr=DOUBLE ',' 'source' '=' source=DataSource
;

FittedNormalRandomVariable returns StochasticModel::FittedNormalRandomVariable: 
	'fitted' 'normal' 'lr' '=' lr=DOUBLE ',' 'source' '=' source=DataSource
;

FittedGammaRandomVariable returns StochasticModel::FittedGammaRandomVariable: 
	'fitted' 'gamma' 'lr' '=' lr=DOUBLE ',' 'source' '=' source=DataSource
;


CategoricalProbabaility returns StochasticModel::CategoricalProbabaility: 
	probability=DOUBLE
;


DiracProcess returns StochasticModel::DiracProcess: 
	"Dirac" "source" "=" source=DataSource
;


FittedGaussianProcess returns StochasticModel::FittedGaussianProcess: 
	("GP"|"Gauss" "Process") "kernel" "="kernel=Kernel ("," "lr" "=" lr=DOUBLE)? "," "source" "="source=DataSource
;


Kernel returns StochasticModel::Kernel: 
	 BrownianKernel | LinearKernel | RBFKernel | PeriodicKernel |SumKernel 
;


SumKernel returns StochasticModel::SumKernel: 
	"(" kernels+=Kernel "+" kernels+=Kernel ")"
;



BrownianKernel returns StochasticModel::BrownianKernel: 
	{StochasticModel::BrownianKernel} "Brownian"
;

RBFKernel returns StochasticModel::RBFKernel: 
	{StochasticModel::RBFKernel} "RBF"
;

LinearKernel returns StochasticModel::LinearKernel: 
	{StochasticModel::LinearKernel} "Linear"
;

PeriodicKernel returns StochasticModel::PeriodicKernel: 
	{StochasticModel::PeriodicKernel} "Periodic"
;


DataSource returns StochasticModel::DataSource: 
	InfluxDB | PythonSimulation
;

InfluxDB returns StochasticModel::InfluxDB: 
	"InfluxDB" "(" "db" ":" dbname=STRING "," "ip" ":" ip=STRING "," "port" ":"  port=STRING "," "query" ":" query=STRING ")"
;

PythonSimulation returns StochasticModel::PythonSimulation: 
	"Python" "(" script=STRING ")"
;


terminal DOUBLE returns Ecore::EDouble:
	('0'..'9')+ ('.' ('0'..'9')+)
;




//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

//terminal STRING:
//			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
//			"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
//		;
//terminal ML_COMMENT : '/*' -> '*/';
//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

//terminal WS         : (' '|'\t'|'\r'|'\n')+;

//terminal ANY_OTHER: .;