/*
 * generated by Xtext 2.23.0.M1
 */
package hu.bme.mit.gamma.fmeda.language.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import hu.bme.mit.gamma.fmeda.model.HardwarePartFailureModeReference
import hu.bme.mit.gamma.fmeda.model.ThisPartFailureModeReference
import hu.bme.mit.gamma.fmeda.model.FailureModeReference

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class FMEDALanguageGenerator extends AbstractGenerator {
	
	
		val ename="fault"
		val modeltype="sync"
		val sctname="FailureModeSCT"
		val sctportname="FaultPort"
		
		
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val fmedaPackage = resource.contents.get(0) as hu.bme.mit.gamma.fmeda.model.Package
		val ifname=fmedaPackage.name+"FMEDAInterface"

}/* 
		
		fsa.generateFile(fmedaPackage.name+"IF.gcd",
'''

package  «fmedaPackage.name»IF

interface «ifname» {
	out event «ename»
}


'''
		)
		
		fsa.generateFile(fmedaPackage.name+"SCT.gcd",

'''		

package  «fmedaPackage.name»SCT

import "«fmedaPackage.name»IF.gcd"
		
statechart «sctname» [
	port "«sctportname»IN : requires «ifname»,
	port «sctportname»OUT : provides «ifname»
]{
	transition from State0 to State0 when «sctportname»IN.«ename» / raise	«sctportname»OUT.«ename»;
	transition from Entry0 to State0
	region main_region {
		state State0
		initial Entry0
	}
}

'''		)

		fsa.generateFile(fmedaPackage.name+".gcd",

'''		

package  «fmedaPackage.name»

import "«fmedaPackage.name»IF.gcd"
import "«fmedaPackage.name»SCT.gcd"


«FOR comp : fmedaPackage.components»
	«modeltype» «comp.name» [
	
	//numper of failure modes : «var i=comp.failuremodes.length»
	
	«FOR fm : comp.failuremodes»
		// «i--»
		port «fm.name»IN : requires «ifname» ,
		port «fm.name»OUT : provides «ifname» «IF i!=0»,«ENDIF» 
	«ENDFOR»
	
	]{
			«FOR fm : comp.failuremodes»
				component «fm.name»SCT : «sctname» ;
				bind «fm.name»SCT.«sctportname»IN -> «fm.name»IN;
				bind «fm.name»SCT.«sctportname»OUT -> «fm.name»OUT;
			«ENDFOR»
			
			«FOR subcomp : comp.subcomponents»
				component «subcomp.name» : «subcomp.name» ;
			«ENDFOR»
			
			«FOR fp : comp.failurepropagations»
				channel [«genFMRefOut(fp.cause)»] -o)- «var j = fp.effect.length» [«FOR effect : fp.effect» «genFMRefIn(effect)»«IF (j--)!=1»,«ENDIF»«ENDFOR»]
			«ENDFOR»
	}		

«ENDFOR»
'''
		)
	}
	
def dispatch String genFMRefOut(ThisPartFailureModeReference ref){
	'''«ref.failuremode.name»SCT.«sctportname»OUT'''
}
def dispatch String genFMRefIn(ThisPartFailureModeReference ref){
	'''«ref.failuremode.name»SCT.«sctportname»IN'''
}
def dispatch String genFMRefOut(HardwarePartFailureModeReference ref){
	'''«ref.failuremode.name».«sctportname»OUT'''
}
def dispatch String genFMRefIn(HardwarePartFailureModeReference ref){
	'''«ref.failuremode.name».«sctportname»IN'''
}
	
*/ 

}

